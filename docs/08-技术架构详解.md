# ğŸ—ï¸ æŠ€æœ¯æ¶æ„è¯¦è§£

> ğŸ¯ **æ·±åº¦è§£æ**ï¼šå…¨é¢å‰–æé¡¹ç›®çš„æŠ€æœ¯æ¶æ„ã€è®¾è®¡ç†å¿µå’Œå®ç°ç»†èŠ‚

## ğŸ“‹ æ¶æ„æ¦‚è§ˆ

æœ¬é¡¹ç›®æ˜¯ä¸€ä¸ªå®Œæ•´çš„ Web3 æ•°æ®æŸ¥è¯¢ç³»ç»Ÿï¼Œå±•ç¤ºäº†ç°ä»£å»ä¸­å¿ƒåŒ–åº”ç”¨çš„æŠ€æœ¯æ¶æ„ï¼š

```mermaid
graph TB
    A[ç”¨æˆ·ç•Œé¢ React App] --> B[Web3 è¿æ¥å±‚ Wagmi]
    A --> C[æ•°æ®æŸ¥è¯¢å±‚ Apollo Client]
    B --> D[é’±åŒ…é›†æˆ MetaMask/WalletConnect]
    B --> E[åŒºå—é“¾ç›´æ¥æŸ¥è¯¢ Ethers.js]
    C --> F[The Graph ç´¢å¼•æŸ¥è¯¢]
    E --> G[ä»¥å¤ªåŠ Sepolia ç½‘ç»œ]
    F --> H[GraphQL å­å›¾ API]
    H --> I[æ™ºèƒ½åˆçº¦äº‹ä»¶]
    I --> G
    J[æ™ºèƒ½åˆçº¦] --> G
    
    style A fill:#e1f5fe
    style G fill:#f3e5f5
    style F fill:#fff3e0
    style J fill:#e8f5e8
```

---

## ğŸ”§ ç¬¬ä¸€éƒ¨åˆ†ï¼šå‰ç«¯æ¶æ„

### 1.1 æŠ€æœ¯æ ˆé€‰æ‹©ç†ç”±

| æŠ€æœ¯ | ç‰ˆæœ¬ | é€‰æ‹©ç†ç”± | æ›¿ä»£æ–¹æ¡ˆ |
|------|------|----------|----------|
| **React** | 19.1.1 | æˆç†Ÿç”Ÿæ€ã€ç»„ä»¶åŒ–ã€hooks | Vue.js, Angular |
| **TypeScript** | 5.8.3 | ç±»å‹å®‰å…¨ã€å¼€å‘æ•ˆç‡ | JavaScript |
| **Vite** | 7.1.2 | å¿«é€Ÿæ„å»ºã€çƒ­æ›´æ–° | Webpack, Parcel |
| **Wagmi** | 2.16.4 | Web3 React hooks | Web3React |
| **Ethers.js** | 6.15.0 | ä»¥å¤ªåŠäº¤äº’åº“ | Web3.js |

### 1.2 ç»„ä»¶æ¶æ„è®¾è®¡

```typescript
// ç»„ä»¶å±‚çº§æ¶æ„
App (æ ¹ç»„ä»¶)
â”œâ”€â”€ ErrorBoundary (é”™è¯¯è¾¹ç•Œ)
â”œâ”€â”€ Header (å¯¼èˆªå¤´)
â””â”€â”€ TabContainer (æ ‡ç­¾é¡µå®¹å™¨)
    â”œâ”€â”€ TransactionQuery (äº¤æ˜“æŸ¥è¯¢)
    â”‚   â”œâ”€â”€ QueryForm (æŸ¥è¯¢è¡¨å•)
    â”‚   â”œâ”€â”€ DataSourceSelector (æ•°æ®æºé€‰æ‹©)
    â”‚   â””â”€â”€ ResultDisplay (ç»“æœå±•ç¤º)
    â”œâ”€â”€ AddressQuery (åœ°å€æŸ¥è¯¢)
    â”‚   â”œâ”€â”€ AddressInput (åœ°å€è¾“å…¥)
    â”‚   â””â”€â”€ TransactionList (äº¤æ˜“åˆ—è¡¨)
    â”œâ”€â”€ WalletTransfer (é’±åŒ…è½¬è´¦)
    â”‚   â”œâ”€â”€ WalletConnector (é’±åŒ…è¿æ¥)
    â”‚   â”œâ”€â”€ TransferForm (è½¬è´¦è¡¨å•)
    â”‚   â””â”€â”€ TransactionStatus (äº¤æ˜“çŠ¶æ€)
    â””â”€â”€ TransactionList (æ•°æ®æ¦‚è§ˆ)
        â”œâ”€â”€ StatsDisplay (ç»Ÿè®¡å±•ç¤º)
        â””â”€â”€ RecentTransactions (æœ€è¿‘äº¤æ˜“)
```

### 1.3 çŠ¶æ€ç®¡ç†ç­–ç•¥

```typescript
// hooks/useTransactionQuery.ts - æ•°æ®çŠ¶æ€ç®¡ç†
interface TransactionState {
  data: Transaction[] | null;
  loading: boolean;
  error: ApolloError | null;
  refetch: () => void;
}

// çŠ¶æ€ç®¡ç†æ¨¡å¼ï¼š
// 1. æœ¬åœ°çŠ¶æ€ï¼šuseState (ç®€å•UIçŠ¶æ€)
// 2. æœåŠ¡å™¨çŠ¶æ€ï¼šApollo Client + React Query (è¿œç¨‹æ•°æ®)
// 3. Web3çŠ¶æ€ï¼šWagmi (é’±åŒ…å’ŒåŒºå—é“¾çŠ¶æ€)

export const useTransactionQuery = (hash: string): TransactionState => {
  const { data, loading, error, refetch } = useQuery<TransactionData>(
    GET_TRANSACTION,
    {
      variables: { hash },
      skip: !hash,
      errorPolicy: 'all', // æ˜¾ç¤ºéƒ¨åˆ†æ•°æ®å³ä½¿æœ‰é”™è¯¯
      fetchPolicy: 'cache-and-network' // ç¼“å­˜ä¼˜å…ˆï¼Œåå°æ›´æ–°
    }
  );

  return {
    data: data?.transaction ? [data.transaction] : null,
    loading,
    error,
    refetch
  };
};
```

### 1.4 æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

```typescript
// 1. ç»„ä»¶æ‡’åŠ è½½
const TransactionQuery = lazy(() => import('./components/TransactionQuery'));
const AddressQuery = lazy(() => import('./components/AddressQuery'));

// 2. memo ä¼˜åŒ–æ¸²æŸ“
const TransactionList = memo(({ transactions }: Props) => {
  return (
    <div>
      {transactions.map(tx => (
        <TransactionItem key={tx.id} transaction={tx} />
      ))}
    </div>
  );
});

// 3. useMemo ç¼“å­˜è®¡ç®—ç»“æœ
const expensiveValue = useMemo(() => {
  return transactions.reduce((sum, tx) => sum + Number(tx.value), 0);
}, [transactions]);

// 4. useCallback ç¼“å­˜å‡½æ•°å¼•ç”¨
const handleTransactionClick = useCallback((txHash: string) => {
  onTransactionSelect(txHash);
}, [onTransactionSelect]);
```

---

## ğŸŒ ç¬¬äºŒéƒ¨åˆ†ï¼šWeb3 é›†æˆæ¶æ„

### 2.1 Wagmi é…ç½®è¯¦è§£

```typescript
// config/wagmi.ts
import { createConfig, http } from 'wagmi';
import { sepolia } from 'wagmi/chains';
import { metaMask, walletConnect } from 'wagmi/connectors';

const projectId = 'your-walletconnect-project-id';

export const wagmiConfig = createConfig({
  chains: [sepolia],
  connectors: [
    metaMask(), // MetaMask è¿æ¥å™¨
    walletConnect({ 
      projectId,
      metadata: {
        name: 'Sepolia Transaction Explorer',
        description: 'Web3 Data Query System',
        url: 'https://your-domain.com',
        icons: ['https://your-domain.com/icon.png']
      }
    })
  ],
  transports: {
    [sepolia.id]: http('https://rpc.sepolia.org')
  },
  // å…¨å±€é…ç½®
  ssr: false, // å®¢æˆ·ç«¯æ¸²æŸ“
  storage: createStorage({
    storage: localStorage, // æŒä¹…åŒ–è¿æ¥çŠ¶æ€
  })
});

// Provider åŒ…è£…
function App() {
  return (
    <WagmiProvider config={wagmiConfig}>
      <QueryClientProvider client={queryClient}>
        {/* åº”ç”¨å†…å®¹ */}
      </QueryClientProvider>
    </WagmiProvider>
  );
}
```

### 2.2 å¤šé’±åŒ…æ”¯æŒæ¶æ„

```typescript
// hooks/useWalletConnection.ts
export const useWalletConnection = () => {
  const { connect, connectors } = useConnect();
  const { disconnect } = useDisconnect();
  const { address, isConnected } = useAccount();

  const connectWallet = useCallback(async (connectorType: 'metamask' | 'walletconnect') => {
    const connector = connectors.find(c => 
      connectorType === 'metamask' ? c.name === 'MetaMask' :
      connectorType === 'walletconnect' ? c.name === 'WalletConnect' :
      false
    );

    if (connector) {
      try {
        await connect({ connector });
      } catch (error) {
        console.error('é’±åŒ…è¿æ¥å¤±è´¥:', error);
        throw error;
      }
    }
  }, [connect, connectors]);

  return {
    address,
    isConnected,
    connectWallet,
    disconnect,
    supportedWallets: ['metamask', 'walletconnect']
  };
};
```

### 2.3 äº¤æ˜“å¤„ç†æµç¨‹

```typescript
// services/transactionService.ts
export class TransactionService {
  
  // å‘é€ETHè½¬è´¦
  static async sendEthTransfer(
    to: string, 
    amount: string, 
    signer: ethers.Signer
  ): Promise<TransactionResponse> {
    try {
      // 1. éªŒè¯åœ°å€æ ¼å¼
      if (!ethers.utils.isAddress(to)) {
        throw new Error('æ— æ•ˆçš„æ¥æ”¶åœ°å€');
      }

      // 2. éªŒè¯é‡‘é¢
      const value = ethers.utils.parseEther(amount);
      if (value.lte(0)) {
        throw new Error('è½¬è´¦é‡‘é¢å¿…é¡»å¤§äº0');
      }

      // 3. æ£€æŸ¥ä½™é¢
      const balance = await signer.getBalance();
      const gasEstimate = await signer.estimateGas({
        to,
        value
      });
      
      const gasPrice = await signer.getGasPrice();
      const totalCost = value.add(gasEstimate.mul(gasPrice));
      
      if (balance.lt(totalCost)) {
        throw new Error('ä½™é¢ä¸è¶³ä»¥å®Œæˆè½¬è´¦');
      }

      // 4. å‘é€äº¤æ˜“
      const tx = await signer.sendTransaction({
        to,
        value,
        gasLimit: gasEstimate.add(21000) // æ·»åŠ ç¼“å†²
      });

      return tx;
    } catch (error) {
      console.error('è½¬è´¦å¤±è´¥:', error);
      throw error;
    }
  }

  // è°ƒç”¨æ™ºèƒ½åˆçº¦
  static async callContract(
    contract: ethers.Contract,
    methodName: string,
    args: any[],
    options: { value?: string; gasLimit?: number } = {}
  ): Promise<TransactionResponse> {
    try {
      const method = contract[methodName];
      if (!method) {
        throw new Error(`åˆçº¦æ–¹æ³• ${methodName} ä¸å­˜åœ¨`);
      }

      const tx = await method(...args, {
        value: options.value ? ethers.utils.parseEther(options.value) : 0,
        gasLimit: options.gasLimit || 200000
      });

      return tx;
    } catch (error) {
      console.error('åˆçº¦è°ƒç”¨å¤±è´¥:', error);
      throw error;
    }
  }
}
```

---

## ğŸ“Š ç¬¬ä¸‰éƒ¨åˆ†ï¼šæ•°æ®å±‚æ¶æ„

### 3.1 åŒæ•°æ®æºè®¾è®¡

é¡¹ç›®é‡‡ç”¨åŒæ•°æ®æºæ¶æ„ï¼š

```typescript
// services/dataSourceManager.ts
export enum DataSource {
  RPC = 'rpc',
  GRAPH = 'graph'
}

export class DataSourceManager {
  private rpcService: EthereumService;
  private graphService: ApolloClient<NormalizedCacheObject>;

  constructor() {
    this.rpcService = new EthereumService();
    this.graphService = apolloClient;
  }

  // æ™ºèƒ½æ•°æ®æºé€‰æ‹©
  async getTransaction(hash: string, preferredSource?: DataSource) {
    switch (preferredSource) {
      case DataSource.RPC:
        return this.getTransactionFromRPC(hash);
      
      case DataSource.GRAPH:
        return this.getTransactionFromGraph(hash);
      
      default:
        // è‡ªåŠ¨é€‰æ‹©æœ€ä½³æ•°æ®æº
        return this.getTransactionAuto(hash);
    }
  }

  private async getTransactionAuto(hash: string) {
    try {
      // é¦–å…ˆå°è¯• The Graph (æ›´å¿«)
      const graphResult = await this.getTransactionFromGraph(hash);
      if (graphResult) {
        return { ...graphResult, source: DataSource.GRAPH };
      }
    } catch (error) {
      console.warn('GraphæŸ¥è¯¢å¤±è´¥ï¼Œé™çº§åˆ°RPC:', error);
    }

    // é™çº§åˆ° RPC æŸ¥è¯¢
    const rpcResult = await this.getTransactionFromRPC(hash);
    return { ...rpcResult, source: DataSource.RPC };
  }
}
```

### 3.2 RPC æœåŠ¡æ¶æ„

```typescript
// services/ethereumService.ts
export class EthereumService {
  private providers: ethers.JsonRpcProvider[];
  private currentProviderIndex: number = 0;

  constructor() {
    // å¤šRPCèŠ‚ç‚¹å®¹é”™
    this.providers = SEPOLIA_RPC_URLS.map(url => 
      new ethers.JsonRpcProvider(url, {
        name: 'sepolia',
        chainId: 11155111
      })
    );
  }

  // æ•…éšœè½¬ç§»æœºåˆ¶
  private async tryProviders<T>(
    operation: (provider: ethers.JsonRpcProvider) => Promise<T>
  ): Promise<T> {
    let lastError: Error | null = null;
    
    for (let i = 0; i < this.providers.length; i++) {
      const providerIndex = (this.currentProviderIndex + i) % this.providers.length;
      const provider = this.providers[providerIndex];
      
      try {
        // 10ç§’è¶…æ—¶æ§åˆ¶
        const result = await Promise.race([
          operation(provider),
          new Promise<never>((_, reject) => 
            setTimeout(() => reject(new Error('Request timeout')), 10000)
          )
        ]);
        
        // æˆåŠŸæ—¶æ›´æ–°é¦–é€‰æä¾›å•†
        this.currentProviderIndex = providerIndex;
        return result;
      } catch (error) {
        console.warn(`RPCèŠ‚ç‚¹ ${SEPOLIA_RPC_URLS[providerIndex]} å¤±è´¥:`, error);
        lastError = error instanceof Error ? error : new Error(String(error));
      }
    }
    
    throw new Error(`æ‰€æœ‰RPCèŠ‚ç‚¹éƒ½æ— æ³•è®¿é—®ã€‚æœ€åé”™è¯¯: ${lastError?.message || 'æœªçŸ¥é”™è¯¯'}`);
  }

  // æ‰¹é‡æŸ¥è¯¢ä¼˜åŒ–
  async batchGetTransactions(hashes: string[]) {
    return Promise.allSettled(
      hashes.map(hash => this.getTransactionByHash(hash))
    );
  }
}
```

### 3.3 The Graph é›†æˆ

```typescript
// apolloClient/client.ts
const httpLink = createHttpLink({
  uri: 'https://api.studio.thegraph.com/query/119398/sepolia-transactions/v1.1.1'
});

// é”™è¯¯å¤„ç†é“¾æ¥
const errorLink = onError(({ graphQLErrors, networkError, operation, forward }) => {
  if (graphQLErrors) {
    graphQLErrors.forEach(({ message, locations, path }) => {
      console.error(
        `GraphQLé”™è¯¯: æ¶ˆæ¯: ${message}, ä½ç½®: ${locations}, è·¯å¾„: ${path}`
      );
    });
  }

  if (networkError) {
    console.error(`ç½‘ç»œé”™è¯¯: ${networkError}`);
    
    // ç½‘ç»œé”™è¯¯æ—¶çš„é™çº§ç­–ç•¥
    if (networkError.statusCode === 503) {
      // æœåŠ¡ä¸å¯ç”¨ï¼Œå¯ä»¥é™çº§åˆ°RPCæŸ¥è¯¢
      console.warn('The GraphæœåŠ¡ä¸å¯ç”¨ï¼Œå»ºè®®ä½¿ç”¨RPCæŸ¥è¯¢');
    }
  }
});

// é‡è¯•é“¾æ¥
const retryLink = new RetryLink({
  delay: {
    initial: 300,
    max: Infinity,
    jitter: true
  },
  attempts: {
    max: 3,
    retryIf: (error) => !!error
  }
});

export const apolloClient = new ApolloClient({
  link: ApolloLink.from([
    errorLink,
    retryLink,
    httpLink
  ]),
  cache: new InMemoryCache({
    typePolicies: {
      Transaction: {
        fields: {
          // è‡ªå®šä¹‰ç¼“å­˜ç­–ç•¥
          timestamp: {
            read: (existing) => existing ? Number(existing) : null
          }
        }
      }
    }
  }),
  defaultOptions: {
    watchQuery: {
      errorPolicy: 'all',
      fetchPolicy: 'cache-and-network'
    }
  }
});
```

---

## ğŸ” ç¬¬å››éƒ¨åˆ†ï¼šæ™ºèƒ½åˆçº¦æ¶æ„

### 4.1 åˆçº¦è®¾è®¡æ¨¡å¼

```solidity
// åˆçº¦é‡‡ç”¨äº†å¤šç§è®¾è®¡æ¨¡å¼
contract SimpleTransferContract {
    using SafeMath for uint256; // åº“æ¨¡å¼
    
    // 1. è®¿é—®æ§åˆ¶æ¨¡å¼
    address public owner;
    mapping(address => bool) public authorized;
    
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }
    
    modifier onlyAuthorized() {
        require(authorized[msg.sender] || msg.sender == owner, "Not authorized");
        _;
    }
    
    // 2. ç´§æ€¥åœæ­¢æ¨¡å¼
    bool public paused = false;
    
    modifier whenNotPaused() {
        require(!paused, "Contract paused");
        _;
    }
    
    function pause() external onlyOwner {
        paused = true;
        emit Paused(msg.sender);
    }
    
    // 3. çŠ¶æ€æœºæ¨¡å¼
    enum ContractState { Active, Paused, Deprecated }
    ContractState public state = ContractState.Active;
    
    // 4. å·¥å‚æ¨¡å¼ (å¦‚æœéœ€è¦åˆ›å»ºå¤šä¸ªå®ä¾‹)
    mapping(address => address[]) public userContracts;
    
    function createUserContract() external returns (address) {
        SimpleTransferContract newContract = new SimpleTransferContract();
        userContracts[msg.sender].push(address(newContract));
        return address(newContract);
    }
}
```

### 4.2 äº‹ä»¶é©±åŠ¨æ¶æ„

```solidity
contract EventDrivenContract {
    // äº‹ä»¶é©±åŠ¨çš„æ•°æ®æµ
    event DataRequested(address indexed requester, bytes32 indexed requestId);
    event DataProvided(bytes32 indexed requestId, bytes data);
    event StateChanged(uint256 indexed oldState, uint256 indexed newState);
    
    mapping(bytes32 => bool) public processedRequests;
    
    function requestData(string calldata query) external {
        bytes32 requestId = keccak256(abi.encodePacked(msg.sender, query, block.timestamp));
        
        emit DataRequested(msg.sender, requestId);
        
        // å¼‚æ­¥å¤„ç†é€»è¾‘
        processedRequests[requestId] = false;
    }
    
    function provideData(bytes32 requestId, bytes calldata data) external onlyAuthorized {
        require(!processedRequests[requestId], "Already processed");
        
        processedRequests[requestId] = true;
        emit DataProvided(requestId, data);
    }
}
```

### 4.3 Gas ä¼˜åŒ–æ¶æ„

```solidity
contract GasOptimizedContract {
    // 1. ç´§å‡‘å­˜å‚¨
    struct Transaction {
        address from;        // 20 bytes
        address to;          // 20 bytes
        uint96 value;        // 12 bytes (è¶³å¤Ÿå­˜å‚¨å¤§éƒ¨åˆ†é‡‘é¢)
        uint32 timestamp;    // 4 bytes (2106å¹´å‰å¤Ÿç”¨)
        // æ€»å…± 56 bytesï¼Œå ç”¨2ä¸ªå­˜å‚¨æ§½
    }
    
    // 2. æ‰¹é‡æ“ä½œ
    function batchTransfer(
        address[] calldata recipients,
        uint256[] calldata amounts
    ) external {
        uint256 length = recipients.length;
        // ç¼“å­˜æ•°ç»„é•¿åº¦
        for (uint256 i = 0; i < length;) {
            _transfer(msg.sender, recipients[i], amounts[i]);
            unchecked { ++i; } // å®‰å…¨çš„æƒ…å†µä¸‹è·³è¿‡æº¢å‡ºæ£€æŸ¥
        }
    }
    
    // 3. å­˜å‚¨ä¼˜åŒ–
    mapping(address => uint256) private balances;
    
    function transfer(address to, uint256 amount) external {
        uint256 fromBalance = balances[msg.sender]; // ä¸€æ¬¡è¯»å–
        require(fromBalance >= amount, "Insufficient balance");
        
        // æ‰¹é‡æ›´æ–°
        balances[msg.sender] = fromBalance - amount;
        balances[to] += amount;
        
        emit Transfer(msg.sender, to, amount);
    }
}
```

---

## ğŸš€ ç¬¬äº”éƒ¨åˆ†ï¼šéƒ¨ç½²å’Œè¿ç»´æ¶æ„

### 5.1 å¤šç¯å¢ƒéƒ¨ç½²

```javascript
// hardhat.config.js - ç¯å¢ƒç®¡ç†
const environments = {
  development: {
    url: "http://127.0.0.1:8545",
    accounts: ["0x..."], // å¼€å‘ç§é’¥
    gasPrice: 1000000000, // 1 Gwei
    gas: 8000000,
    timeout: 20000
  },
  
  staging: {
    url: process.env.SEPOLIA_URL,
    accounts: [process.env.STAGING_PRIVATE_KEY],
    gasPrice: "auto",
    gas: "auto"
  },
  
  production: {
    url: process.env.MAINNET_URL,
    accounts: [process.env.PROD_PRIVATE_KEY],
    gasPrice: "auto",
    gas: 6000000,
    timeout: 300000 // 5 minutes
  }
};

module.exports = {
  solidity: {
    version: "0.8.30",
    settings: {
      optimizer: {
        enabled: true,
        runs: 200,
        details: {
          yul: true,
          yulDetails: {
            stackAllocation: true,
            optimizerSteps: "dhfoDgvulfnTUtnIf"
          }
        }
      }
    }
  },
  networks: environments,
  etherscan: {
    apiKey: {
      sepolia: process.env.ETHERSCAN_API_KEY,
      mainnet: process.env.ETHERSCAN_API_KEY
    }
  }
};
```

### 5.2 ç›‘æ§å’Œæ—¥å¿—ç³»ç»Ÿ

```typescript
// utils/monitoring.ts
export class MonitoringService {
  private static instance: MonitoringService;
  private metrics: Map<string, number> = new Map();
  private logs: LogEntry[] = [];

  static getInstance() {
    if (!MonitoringService.instance) {
      MonitoringService.instance = new MonitoringService();
    }
    return MonitoringService.instance;
  }

  // æ€§èƒ½ç›‘æ§
  trackPerformance(operation: string, duration: number) {
    this.metrics.set(`${operation}_duration`, duration);
    
    if (duration > 5000) { // è¶…è¿‡5ç§’çš„æ“ä½œ
      this.logWarning(`æ…¢æ“ä½œæ£€æµ‹: ${operation} è€—æ—¶ ${duration}ms`);
    }
  }

  // é”™è¯¯è¿½è¸ª
  trackError(error: Error, context: string) {
    const errorLog: LogEntry = {
      level: 'error',
      message: error.message,
      context,
      timestamp: Date.now(),
      stack: error.stack
    };
    
    this.logs.push(errorLog);
    
    // å‘é€åˆ°å¤–éƒ¨ç›‘æ§æœåŠ¡
    if (process.env.NODE_ENV === 'production') {
      this.sendToExternalService(errorLog);
    }
  }

  // ç”¨æˆ·è¡Œä¸ºåˆ†æ
  trackUserAction(action: string, params: Record<string, any>) {
    const actionLog: LogEntry = {
      level: 'info',
      message: `ç”¨æˆ·æ“ä½œ: ${action}`,
      context: 'user_action',
      timestamp: Date.now(),
      data: params
    };
    
    this.logs.push(actionLog);
  }

  private sendToExternalService(log: LogEntry) {
    // é›†æˆ Sentryã€LogRocket ç­‰æœåŠ¡
    // æˆ–å‘é€åˆ°è‡ªå®šä¹‰ç›‘æ§ç³»ç»Ÿ
  }
}
```

### 5.3 CI/CD æµæ°´çº¿

```yaml
# .github/workflows/ci-cd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - uses: actions/setup-node@v3
      with:
        node-version: '18'
        cache: 'npm'

    - name: Install dependencies
      run: |
        cd frontend && npm ci
        cd ../subgraph && npm ci

    - name: Run tests
      run: |
        cd frontend && npm run test:coverage
        cd ../subgraph && npm run test

    - name: Lint check
      run: |
        cd frontend && npm run lint
        cd frontend && npm run type-check

  deploy-staging:
    needs: test
    if: github.ref == 'refs/heads/develop'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Deploy to staging
      run: |
        cd frontend && npm run build:staging
        # éƒ¨ç½²åˆ°æµ‹è¯•ç¯å¢ƒ

  deploy-production:
    needs: test
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - name: Deploy to production
      run: |
        cd frontend && npm run build:production
        # éƒ¨ç½²åˆ°ç”Ÿäº§ç¯å¢ƒ
```

---

## ğŸ“ˆ ç¬¬å…­éƒ¨åˆ†ï¼šæ€§èƒ½ä¼˜åŒ–æ¶æ„

### 6.1 å‰ç«¯æ€§èƒ½ä¼˜åŒ–

```typescript
// 1. ç»„ä»¶å±‚é¢ä¼˜åŒ–
const OptimizedTransactionList = React.memo(({ transactions }: Props) => {
  // è™šæ‹Ÿæ»šåŠ¨å¤„ç†å¤§é‡æ•°æ®
  const [visibleItems, setVisibleItems] = useState<Transaction[]>([]);
  const containerRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const container = containerRef.current;
    if (!container) return;

    const handleScroll = throttle(() => {
      const scrollTop = container.scrollTop;
      const itemHeight = 60; // æ¯é¡¹é«˜åº¦
      const visibleCount = Math.ceil(container.clientHeight / itemHeight);
      const startIndex = Math.floor(scrollTop / itemHeight);
      
      setVisibleItems(
        transactions.slice(startIndex, startIndex + visibleCount + 5)
      );
    }, 100);

    container.addEventListener('scroll', handleScroll);
    return () => container.removeEventListener('scroll', handleScroll);
  }, [transactions]);

  return (
    <div ref={containerRef} style={{ height: '400px', overflow: 'auto' }}>
      {visibleItems.map((tx, index) => (
        <TransactionItem key={tx.id} transaction={tx} />
      ))}
    </div>
  );
});

// 2. æ•°æ®ç¼“å­˜ç­–ç•¥
class DataCacheManager {
  private cache: Map<string, { data: any; timestamp: number; ttl: number }> = new Map();

  set(key: string, data: any, ttl: number = 300000) { // 5åˆ†é’Ÿé»˜è®¤TTL
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
      ttl
    });
  }

  get(key: string) {
    const item = this.cache.get(key);
    if (!item) return null;

    if (Date.now() - item.timestamp > item.ttl) {
      this.cache.delete(key);
      return null;
    }

    return item.data;
  }

  // æ™ºèƒ½é¢„åŠ è½½
  preload(keys: string[]) {
    return Promise.allSettled(
      keys.map(key => this.fetchData(key))
    );
  }
}
```

### 6.2 ç½‘ç»œè¯·æ±‚ä¼˜åŒ–

```typescript
// services/requestOptimizer.ts
class RequestOptimizer {
  private requestQueue: Map<string, Promise<any>> = new Map();
  private rateLimiter = new Map<string, number>();

  // è¯·æ±‚å»é‡
  async dedupedRequest<T>(key: string, requestFn: () => Promise<T>): Promise<T> {
    if (this.requestQueue.has(key)) {
      return this.requestQueue.get(key) as Promise<T>;
    }

    const promise = requestFn().finally(() => {
      this.requestQueue.delete(key);
    });

    this.requestQueue.set(key, promise);
    return promise;
  }

  // é€Ÿç‡é™åˆ¶
  async rateLimitedRequest<T>(
    endpoint: string, 
    requestFn: () => Promise<T>,
    maxRequestsPerSecond: number = 10
  ): Promise<T> {
    const now = Date.now();
    const lastRequest = this.rateLimiter.get(endpoint) || 0;
    const minInterval = 1000 / maxRequestsPerSecond;

    if (now - lastRequest < minInterval) {
      await new Promise(resolve => 
        setTimeout(resolve, minInterval - (now - lastRequest))
      );
    }

    this.rateLimiter.set(endpoint, Date.now());
    return requestFn();
  }

  // æ‰¹é‡è¯·æ±‚ä¼˜åŒ–
  async batchRequests<T>(
    requests: Array<() => Promise<T>>,
    batchSize: number = 5
  ): Promise<T[]> {
    const results: T[] = [];
    
    for (let i = 0; i < requests.length; i += batchSize) {
      const batch = requests.slice(i, i + batchSize);
      const batchResults = await Promise.allSettled(
        batch.map(request => request())
      );
      
      results.push(...batchResults.map(result => 
        result.status === 'fulfilled' ? result.value : null
      ).filter(Boolean));
    }

    return results;
  }
}
```

---

## ğŸ”’ ç¬¬ä¸ƒéƒ¨åˆ†ï¼šå®‰å…¨æ¶æ„

### 7.1 å‰ç«¯å®‰å…¨æªæ–½

```typescript
// security/securityManager.ts
class SecurityManager {
  
  // è¾“å…¥éªŒè¯
  static validateEthereumAddress(address: string): boolean {
    try {
      ethers.utils.getAddress(address);
      return true;
    } catch {
      return false;
    }
  }

  // XSS é˜²æŠ¤
  static sanitizeInput(input: string): string {
    return input
      .replace(/</g, '&lt;')
      .replace(/>/g, '&gt;')
      .replace(/"/g, '&quot;')
      .replace(/'/g, '&#x27;')
      .replace(/\//g, '&#x2F;');
  }

  // æ•æ„Ÿä¿¡æ¯è¿‡æ»¤
  static filterSensitiveData(data: any): any {
    const sensitiveKeys = ['privateKey', 'mnemonic', 'password'];
    
    if (typeof data === 'object' && data !== null) {
      const filtered = { ...data };
      for (const key of sensitiveKeys) {
        if (key in filtered) {
          filtered[key] = '[REDACTED]';
        }
      }
      return filtered;
    }
    
    return data;
  }

  // è¯·æ±‚ç­¾åéªŒè¯
  static verifyRequestSignature(
    message: string, 
    signature: string, 
    expectedAddress: string
  ): boolean {
    try {
      const recoveredAddress = ethers.utils.verifyMessage(message, signature);
      return recoveredAddress.toLowerCase() === expectedAddress.toLowerCase();
    } catch {
      return false;
    }
  }
}
```

### 7.2 æ™ºèƒ½åˆçº¦å®‰å…¨æ¨¡å¼

```solidity
// contracts/security/SecurityFeatures.sol
contract SecurityFeatures {
    // 1. é‡å…¥æ”»å‡»é˜²æŠ¤
    uint256 private _status;
    uint256 private constant _NOT_ENTERED = 1;
    uint256 private constant _ENTERED = 2;

    modifier nonReentrant() {
        require(_status != _ENTERED, "ReentrancyGuard: reentrant call");
        _status = _ENTERED;
        _;
        _status = _NOT_ENTERED;
    }

    // 2. æƒé™ç®¡ç†
    mapping(bytes32 => mapping(address => bool)) private _roles;
    
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");
    bytes32 public constant OPERATOR_ROLE = keccak256("OPERATOR_ROLE");

    modifier onlyRole(bytes32 role) {
        require(hasRole(role, msg.sender), "AccessControl: unauthorized");
        _;
    }

    function hasRole(bytes32 role, address account) public view returns (bool) {
        return _roles[role][account];
    }

    // 3. ç´§æ€¥æš‚åœ
    bool private _paused;
    
    event Paused(address account);
    event Unpaused(address account);

    modifier whenNotPaused() {
        require(!paused(), "Pausable: paused");
        _;
    }

    function paused() public view returns (bool) {
        return _paused;
    }

    // 4. å‡çº§æ¨¡å¼
    address private _implementation;
    
    function upgradeTo(address newImplementation) external onlyRole(ADMIN_ROLE) {
        require(newImplementation != address(0), "Invalid implementation");
        _implementation = newImplementation;
    }
}
```

---

## ğŸ“Š ç¬¬å…«éƒ¨åˆ†ï¼šæ•°æ®æµæ¶æ„

### 8.1 å®Œæ•´æ•°æ®æµå›¾

```
ç”¨æˆ·æ“ä½œ
    â†“
UIç»„ä»¶ (React)
    â†“
ä¸šåŠ¡é€»è¾‘å±‚ (Hooks)
    â†“        â†“
Web3å±‚    æ•°æ®æŸ¥è¯¢å±‚
(Wagmi)   (Apollo Client)
    â†“        â†“
é’±åŒ…/åˆçº¦  The Graph API
    â†“        â†“
åŒºå—é“¾ç½‘ç»œ â† æ™ºèƒ½åˆçº¦äº‹ä»¶
```

### 8.2 çŠ¶æ€åŒæ­¥æœºåˆ¶

```typescript
// utils/stateSynchronizer.ts
export class StateSynchronizer {
  private subscribers: Map<string, Set<(data: any) => void>> = new Map();

  // è®¢é˜…æ•°æ®å˜åŒ–
  subscribe(key: string, callback: (data: any) => void) {
    if (!this.subscribers.has(key)) {
      this.subscribers.set(key, new Set());
    }
    this.subscribers.get(key)!.add(callback);
  }

  // å‘å¸ƒæ•°æ®å˜åŒ–
  publish(key: string, data: any) {
    const callbacks = this.subscribers.get(key);
    if (callbacks) {
      callbacks.forEach(callback => callback(data));
    }
  }

  // åŒæ­¥åŒºå—é“¾çŠ¶æ€
  async syncBlockchainState() {
    const latestBlock = await ethereumService.getCurrentBlockNumber();
    this.publish('latestBlock', latestBlock);

    // æ£€æŸ¥å¾…å¤„ç†äº¤æ˜“
    const pendingTxs = await this.getPendingTransactions();
    this.publish('pendingTransactions', pendingTxs);
  }

  private async getPendingTransactions() {
    // ä»æœ¬åœ°å­˜å‚¨æˆ–çŠ¶æ€ç®¡ç†ä¸­è·å–å¾…å¤„ç†äº¤æ˜“
    return JSON.parse(localStorage.getItem('pendingTxs') || '[]');
  }
}
```

---

## âœ… æ¶æ„æ€»ç»“

### æŠ€æœ¯äº®ç‚¹

1. **åŒæ•°æ®æºæ¶æ„**ï¼šRPC + The Graphï¼Œå¹³è¡¡å®æ—¶æ€§å’Œæ€§èƒ½
2. **å¤šé‡å®¹é”™æœºåˆ¶**ï¼šRPCèŠ‚ç‚¹æ•…éšœè½¬ç§»ã€GraphQLé™çº§ç­–ç•¥
3. **ç»„ä»¶åŒ–è®¾è®¡**ï¼šé«˜å†…èšä½è€¦åˆï¼Œæ˜“äºç»´æŠ¤å’Œæ‰©å±•
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šè™šæ‹Ÿæ»šåŠ¨ã€è¯·æ±‚å»é‡ã€æ™ºèƒ½ç¼“å­˜
5. **å®‰å…¨ç¬¬ä¸€**ï¼šå¤šå±‚å®‰å…¨é˜²æŠ¤ï¼Œä»å‰ç«¯åˆ°æ™ºèƒ½åˆçº¦

### å¯æ‰©å±•æ€§

- **æ°´å¹³æ‰©å±•**ï¼šæ”¯æŒå¤šé“¾ã€å¤šåˆçº¦
- **å‚ç›´æ‰©å±•**ï¼šæ¨¡å—åŒ–æ¶æ„ä¾¿äºåŠŸèƒ½å¢å¼º
- **å›½é™…åŒ–**ï¼šå¤šè¯­è¨€æ”¯æŒé¢„ç•™
- **ä¸»é¢˜ç³»ç»Ÿ**ï¼šUIå¯å®šåˆ¶åŒ–

### ç»´æŠ¤æ€§

- **TypeScript**ï¼šç±»å‹å®‰å…¨ï¼Œå‡å°‘è¿è¡Œæ—¶é”™è¯¯
- **å•å…ƒæµ‹è¯•**ï¼šè¦†ç›–ç‡ > 80%
- **æ–‡æ¡£å®Œå–„**ï¼šä»£ç æ³¨é‡Š + æŠ€æœ¯æ–‡æ¡£
- **ç›‘æ§å®Œå¤‡**ï¼šé”™è¯¯è¿½è¸ª + æ€§èƒ½ç›‘æ§

è¿™ä¸ªæ¶æ„ä¸ºç°ä»£ Web3 åº”ç”¨æä¾›äº†ä¸€ä¸ªåšå®ã€å¯é ã€å¯æ‰©å±•çš„åŸºç¡€! ğŸš€