# ğŸŒ Web3 æŠ€æœ¯æ ˆå®Œå…¨æŒ‡å—

> ğŸ¯ **ä»é›¶å¼€å§‹**ï¼šè¯¦ç»†è§£é‡Šé¡¹ç›®ä¸­ä½¿ç”¨çš„æ¯ä¸ª Web3 æŠ€æœ¯ï¼ŒåŒ…å«åŸç†ã€ä½œç”¨å’Œå®é™…ä½¿ç”¨ç¤ºä¾‹

## ğŸ“š ç›®å½•

1. [Ethers.js - ä»¥å¤ªåŠJavaScriptåº“](#ethersjs---ä»¥å¤ªåŠjavascriptåº“)
2. [The Graph - å»ä¸­å¿ƒåŒ–æ•°æ®ç´¢å¼•](#the-graph---å»ä¸­å¿ƒåŒ–æ•°æ®ç´¢å¼•)
3. [Wagmi - React Web3 Hooks](#wagmi---react-web3-hooks)
4. [GraphQL - æŸ¥è¯¢è¯­è¨€](#graphql---æŸ¥è¯¢è¯­è¨€)
5. [Viem - ç°ä»£ä»¥å¤ªåŠåº“](#viem---ç°ä»£ä»¥å¤ªåŠåº“)
6. [æŠ€æœ¯æ ˆåä½œå…³ç³»](#æŠ€æœ¯æ ˆåä½œå…³ç³»)

---

## ğŸ”— Ethers.js - ä»¥å¤ªåŠJavaScriptåº“

### ğŸ¤” ä»€ä¹ˆæ˜¯ Ethers.jsï¼Ÿ

Ethers.js æ˜¯ä¸€ä¸ªå®Œæ•´çš„ä»¥å¤ªåŠå¼€å‘åº“ï¼Œè®©ä½ å¯ä»¥ç”¨ JavaScript ä¸ä»¥å¤ªåŠåŒºå—é“¾äº¤äº’ã€‚

**ç®€å•ç†è§£**ï¼šå°±åƒæ˜¯ä¸€ä¸ª"ç¿»è¯‘å™¨"ï¼ŒæŠŠå¤æ‚çš„åŒºå—é“¾æ“ä½œå˜æˆç®€å•çš„ JavaScript ä»£ç ã€‚

### ğŸ¯ ä¸»è¦åŠŸèƒ½

#### 1. ğŸ¦ è¿æ¥åŒºå—é“¾ç½‘ç»œ
```javascript
// è¿æ¥åˆ°ä»¥å¤ªåŠç½‘ç»œ
import { ethers } from 'ethers';

// åˆ›å»ºproviderï¼ˆè¿æ¥åˆ°åŒºå—é“¾çš„å…¥å£ï¼‰
const provider = new ethers.JsonRpcProvider('https://ethereum-sepolia-rpc.publicnode.com');

// è·å–å½“å‰åŒºå—å·
const blockNumber = await provider.getBlockNumber();
console.log(`å½“å‰åŒºå—: ${blockNumber}`);
```

#### 2. ğŸ’° æŸ¥è¯¢è´¦æˆ·ä½™é¢
```javascript
// æŸ¥è¯¢æŸä¸ªåœ°å€çš„ ETH ä½™é¢
const address = "0x742d35cc6634C0532925a3b8d007f78e2dcbF2";
const balance = await provider.getBalance(address);

// å°† Wei è½¬æ¢ä¸º ETHï¼ˆæ›´æ˜“è¯»çš„æ ¼å¼ï¼‰
const ethBalance = ethers.formatEther(balance);
console.log(`ä½™é¢: ${ethBalance} ETH`);
```

#### 3. ğŸ“‹ æŸ¥è¯¢äº¤æ˜“ä¿¡æ¯
```javascript
// æ ¹æ®äº¤æ˜“å“ˆå¸ŒæŸ¥è¯¢äº¤æ˜“è¯¦æƒ…
const txHash = "0xabc123...";
const transaction = await provider.getTransaction(txHash);

console.log({
  from: transaction.from,        // å‘é€æ–¹
  to: transaction.to,           // æ¥æ”¶æ–¹
  value: ethers.formatEther(transaction.value), // é‡‘é¢
  gasPrice: transaction.gasPrice.toString()     // Gasä»·æ ¼
});
```

#### 4. ğŸ’¸ å‘é€äº¤æ˜“
```javascript
// åˆ›å»ºé’±åŒ…ï¼ˆéœ€è¦ç§é’¥ï¼‰
const wallet = new ethers.Wallet("your-private-key", provider);

// å‘é€ ETH
const tx = await wallet.sendTransaction({
  to: "0xæ¥æ”¶æ–¹åœ°å€",
  value: ethers.parseEther("0.1") // å‘é€ 0.1 ETH
});

// ç­‰å¾…äº¤æ˜“ç¡®è®¤
const receipt = await tx.wait();
console.log(`äº¤æ˜“æˆåŠŸ: ${receipt.hash}`);
```

### ğŸ—ï¸ åœ¨é¡¹ç›®ä¸­çš„åº”ç”¨

**æ–‡ä»¶ä½ç½®**: `frontend/src/services/ethereumService.ts`

```typescript
export class EthereumService {
  private providers: ethers.JsonRpcProvider[] = [];

  // åˆå§‹åŒ–å¤šä¸ªRPCæä¾›è€…ï¼ˆæé«˜å¯é æ€§ï¼‰
  constructor() {
    const RPC_ENDPOINTS = [
      'https://ethereum-sepolia-rpc.publicnode.com',
      'https://rpc.sepolia.org',
      'https://ethereum-sepolia.publicnode.com'
    ];

    this.providers = RPC_ENDPOINTS.map(url => new ethers.JsonRpcProvider(url));
  }

  // è·å–äº¤æ˜“è¯¦æƒ…ï¼ˆå¸¦é‡è¯•æœºåˆ¶ï¼‰
  async getTransaction(hash: string): Promise<Transaction | null> {
    return this.tryProviders(async (provider) => {
      const tx = await provider.getTransaction(hash);
      if (!tx) return null;

      // æ ¼å¼åŒ–äº¤æ˜“æ•°æ®
      return {
        id: tx.hash,
        hash: tx.hash,
        from: { address: tx.from },
        to: tx.to ? { address: tx.to } : null,
        value: tx.value.toString(),
        gasUsed: tx.gasLimit?.toString() || '0',
        gasPrice: tx.gasPrice?.toString() || '0',
        blockNumber: tx.blockNumber?.toString() || '0',
        timestamp: '0', // éœ€è¦å•ç‹¬æŸ¥è¯¢åŒºå—è·å–
        status: '1',
        transactionIndex: tx.index?.toString() || '0',
        data: tx.data || '0x'
      };
    });
  }
}
```

### ğŸ’¡ å­¦ä¹ è¦ç‚¹

- **Provider**: è¿æ¥åˆ°åŒºå—é“¾ç½‘ç»œçš„å…¥å£ç‚¹
- **Wallet**: ç®¡ç†ç§é’¥å’Œç­¾åäº¤æ˜“
- **Contract**: ä¸æ™ºèƒ½åˆçº¦äº¤äº’
- **Utils**: æ ¼å¼è½¬æ¢å·¥å…·ï¼ˆWei â†” ETHï¼‰

---

## ğŸ“Š The Graph - å»ä¸­å¿ƒåŒ–æ•°æ®ç´¢å¼•

### ğŸ¤” ä»€ä¹ˆæ˜¯ The Graphï¼Ÿ

The Graph æ˜¯ä¸€ä¸ªå»ä¸­å¿ƒåŒ–çš„æ•°æ®ç´¢å¼•åè®®ï¼Œä¸“é—¨ç”¨äºç»„ç»‡åŒºå—é“¾æ•°æ®ã€‚

**ç®€å•ç†è§£**ï¼šå°±åƒç»™åŒºå—é“¾æ•°æ®å»ºç«‹äº†ä¸€ä¸ª"æœç´¢å¼•æ“"ï¼Œè®©ä½ å¯ä»¥å¿«é€ŸæŸ¥è¯¢å¤æ‚çš„é“¾ä¸Šæ•°æ®ã€‚

### ğŸ¯ è§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ

#### é—®é¢˜ï¼šç›´æ¥æŸ¥è¯¢åŒºå—é“¾å¾ˆæ…¢
```javascript
// æƒ³è¦æŸ¥è¯¢æŸä¸ªåœ°å€çš„æ‰€æœ‰äº¤æ˜“è®°å½•ï¼Ÿ
// ä¼ ç»Ÿæ–¹å¼ï¼šéœ€è¦éå†æ¯ä¸ªåŒºå—ï¼Œéå¸¸æ…¢ï¼
const transactions = [];
for (let i = startBlock; i <= endBlock; i++) {
  const block = await provider.getBlock(i);
  for (const txHash of block.transactions) {
    const tx = await provider.getTransaction(txHash);
    if (tx.from === targetAddress || tx.to === targetAddress) {
      transactions.push(tx);
    }
  }
}
// è¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿç”šè‡³å‡ å°æ—¶ï¼
```

#### è§£å†³æ–¹æ¡ˆï¼šThe Graph é¢„å»ºç´¢å¼•
```javascript
// ä½¿ç”¨ The Graphï¼šå‡ æ¯«ç§’å°±èƒ½æŸ¥åˆ°ï¼
const { data } = await apolloClient.query({
  query: gql`
    query GetUserTransactions($userAddress: String!) {
      transferRecords(where: { 
        or: [
          { from: $userAddress },
          { to: $userAddress }
        ]
      }) {
        id
        from { address }
        to { address }
        value
        timestamp
      }
    }
  `,
  variables: { userAddress: "0x123..." }
});
```

### ğŸ—ï¸ The Graph æ¶æ„

```mermaid
graph TB
    A[æ™ºèƒ½åˆçº¦äº‹ä»¶] --> B[Subgraph]
    B --> C[Graph Node]
    C --> D[IPFS å­˜å‚¨]
    C --> E[PostgreSQL æ•°æ®åº“]
    E --> F[GraphQL API]
    F --> G[å‰ç«¯åº”ç”¨]
    
    style B fill:#e1f5fe
    style F fill:#f3e5f5
```

### ğŸ“ Subgraph é…ç½®

#### 1. Schema å®šä¹‰ (schema.graphql)
```graphql
# å®šä¹‰æ•°æ®ç»“æ„
type Account @entity(immutable: false) {
  id: ID!
  address: Bytes!
  transferRecordsSent: [TransferRecord!]! @derivedFrom(field: "from")
  transferRecordsReceived: [TransferRecord!]! @derivedFrom(field: "to")
  recordCount: BigInt!
}

type TransferRecord @entity(immutable: true) {
  id: ID!
  recordId: Bytes!
  from: Account!
  to: Account!
  value: BigInt!
  message: String!
  timestamp: BigInt!
  blockNumber: BigInt!
  transactionHash: Bytes!
}
```

#### 2. æ•°æ®æ˜ å°„ (mapping.ts)
```typescript
// ç›‘å¬æ™ºèƒ½åˆçº¦äº‹ä»¶ï¼Œè‡ªåŠ¨å»ºç«‹ç´¢å¼•
import { TransferRecord as TransferRecordEvent } from "../generated/SimpleTransferContract/SimpleTransferContract"
import { TransferRecord, Account } from "../generated/schema"

export function handleTransferRecord(event: TransferRecordEvent): void {
  // åˆ›å»ºæ–°çš„è½¬è´¦è®°å½•
  let record = new TransferRecord(event.params.recordId.toHexString())
  
  // è®¾ç½®å­—æ®µå€¼
  record.recordId = event.params.recordId
  record.from = getOrCreateAccount(event.params.from).id
  record.to = getOrCreateAccount(event.params.to).id
  record.value = event.params.value
  record.message = event.params.message
  record.timestamp = event.params.timestamp
  record.blockNumber = event.block.number
  record.transactionHash = event.transaction.hash

  // ä¿å­˜åˆ°æ•°æ®åº“
  record.save()
}

// è·å–æˆ–åˆ›å»ºè´¦æˆ·å®ä½“
function getOrCreateAccount(address: Address): Account {
  let account = Account.load(address.toHexString())
  
  if (!account) {
    account = new Account(address.toHexString())
    account.address = address
    account.recordCount = BigInt.fromI32(0)
    account.save()
  }
  
  return account
}
```

#### 3. Subgraph é…ç½® (subgraph.yaml)
```yaml
specVersion: 0.0.5
schema:
  file: ./schema.graphql
dataSources:
  - kind: ethereum
    name: SimpleTransferContract
    network: sepolia
    source:
      address: "0x830B796F55E6A3f86E924297e510B24192A0Ba1c"
      abi: SimpleTransferContract
      startBlock: 9053891
    mapping:
      kind: ethereum/events
      apiVersion: 0.0.7
      language: wasm/assemblyscript
      entities:
        - TransferRecord
        - Account
      eventHandlers:
        - event: TransferRecord(indexed address,indexed address,uint256,uint256,string,bytes32)
          handler: handleTransferRecord
      file: ./src/mapping.ts
```

### ğŸš€ å¼€å‘å’Œéƒ¨ç½²æµç¨‹

```bash
# 1. ç”Ÿæˆä»£ç 
cd subgraph
pnpm codegen    # æ ¹æ®schemaå’ŒABIç”ŸæˆTypeScriptä»£ç 

# 2. æ„å»º
pnpm build      # ç¼–è¯‘mappingä»£ç 

# 3. éƒ¨ç½²åˆ°The Graph Studio
pnpm deploy     # éƒ¨ç½²åˆ°å»ä¸­å¿ƒåŒ–ç½‘ç»œ
```

### ğŸ’¡ å­¦ä¹ è¦ç‚¹

- **Schema**: å®šä¹‰æ•°æ®ç»“æ„ï¼Œç±»ä¼¼æ•°æ®åº“è¡¨ç»“æ„
- **Mapping**: äº‹ä»¶å¤„ç†é€»è¾‘ï¼Œå°†åŒºå—é“¾äº‹ä»¶è½¬æ¢ä¸ºç»“æ„åŒ–æ•°æ®
- **Entity**: æ•°æ®å®ä½“ï¼Œå­˜å‚¨åœ¨å›¾æ•°æ®åº“ä¸­
- **GraphQL**: æŸ¥è¯¢è¯­è¨€ï¼Œç”¨äºè·å–ç»“æ„åŒ–æ•°æ®

---

## âš›ï¸ Wagmi - React Web3 Hooks

### ğŸ¤” ä»€ä¹ˆæ˜¯ Wagmiï¼Ÿ

Wagmi æ˜¯ä¸“ä¸º React è®¾è®¡çš„ Web3 Hooks åº“ï¼Œè®©ä½ å¯ä»¥è½»æ¾åœ°åœ¨ React åº”ç”¨ä¸­é›†æˆåŒºå—é“¾åŠŸèƒ½ã€‚

**ç®€å•ç†è§£**ï¼šå°±åƒ React çš„ useStateã€useEffectï¼Œä½†æ˜¯ä¸“é—¨ç”¨æ¥å¤„ç†åŒºå—é“¾æ“ä½œã€‚

### ğŸ¯ æ ¸å¿ƒæ¦‚å¿µ

#### 1. ğŸ”§ é…ç½® (wagmi.ts)
```typescript
import { createConfig, http } from 'wagmi'
import { sepolia } from 'wagmi/chains'
import { injected, metaMask } from 'wagmi/connectors'

// é…ç½®æ”¯æŒçš„åŒºå—é“¾ç½‘ç»œ
export const wagmiConfig = createConfig({
  chains: [sepolia],  // åªæ”¯æŒSepoliaæµ‹è¯•ç½‘
  connectors: [
    injected(),       // é€šç”¨æ³¨å…¥å¼é’±åŒ…
    metaMask(),      // MetaMaskä¸“ç”¨è¿æ¥å™¨
  ],
  transports: {
    [sepolia.id]: http() // HTTPä¼ è¾“å±‚
  },
})
```

#### 2. ğŸ¦ é’±åŒ…è¿æ¥
```typescript
import { useAccount, useConnect, useDisconnect } from 'wagmi'

function WalletConnection() {
  const { address, isConnected } = useAccount()
  const { connect, connectors } = useConnect()
  const { disconnect } = useDisconnect()

  if (isConnected) {
    return (
      <div>
        <p>å·²è¿æ¥: {address}</p>
        <button onClick={() => disconnect()}>æ–­å¼€è¿æ¥</button>
      </div>
    )
  }

  return (
    <div>
      {connectors.map((connector) => (
        <button 
          key={connector.id} 
          onClick={() => connect({ connector })}
        >
          è¿æ¥ {connector.name}
        </button>
      ))}
    </div>
  )
}
```

#### 3. ğŸ’° ä½™é¢æŸ¥è¯¢
```typescript
import { useBalance } from 'wagmi'

function BalanceDisplay() {
  const { address } = useAccount()
  
  const { data: balance, isLoading } = useBalance({
    address: address,
  })

  if (isLoading) return <div>æŸ¥è¯¢ä½™é¢ä¸­...</div>

  return (
    <div>
      ä½™é¢: {balance?.formatted} {balance?.symbol}
    </div>
  )
}
```

#### 4. ğŸ’¸ å‘é€äº¤æ˜“
```typescript
import { useSendTransaction, useWaitForTransactionReceipt } from 'wagmi'
import { parseEther } from 'viem'

function SendTransaction() {
  const { data: hash, sendTransaction } = useSendTransaction()
  
  // ç­‰å¾…äº¤æ˜“ç¡®è®¤
  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({ 
    hash 
  })

  const handleSend = () => {
    sendTransaction({
      to: '0xæ¥æ”¶æ–¹åœ°å€',
      value: parseEther('0.1') // å‘é€0.1 ETH
    })
  }

  return (
    <div>
      <button onClick={handleSend}>å‘é€äº¤æ˜“</button>
      {isConfirming && <div>ç¡®è®¤äº¤æ˜“ä¸­...</div>}
      {isSuccess && <div>äº¤æ˜“æˆåŠŸ!</div>}
      {hash && <div>äº¤æ˜“å“ˆå¸Œ: {hash}</div>}
    </div>
  )
}
```

### ğŸ—ï¸ åœ¨é¡¹ç›®ä¸­çš„ä½¿ç”¨

**æ–‡ä»¶ä½ç½®**: `frontend/src/components/WalletTransfer.tsx`

```typescript
const WalletTransfer: React.FC = ({ onTransactionSuccess }) => {
  // Wagmi hooks
  const { address, isConnected } = useAccount()
  const { connect, connectors } = useConnect()
  const { data: balance } = useBalance({ address })
  const { data: hash, sendTransaction } = useSendTransaction()
  const { isLoading: isConfirming, isSuccess } = useWaitForTransactionReceipt({ 
    hash 
  })

  // æœ¬åœ°çŠ¶æ€
  const [toAddress, setToAddress] = useState<string>('')
  const [amount, setAmount] = useState<string>('')
  const [message, setMessage] = useState<string>('')

  // å¤„ç†è½¬è´¦
  const handleTransfer = async () => {
    if (!toAddress || !amount || !address) return;
    
    try {
      setIsTransferring(true);
      
      // æ„å»ºäº¤æ˜“å‚æ•°
      const txParams: {
        to: `0x${string}`;
        value: bigint;
        data?: `0x${string}`;
      } = {
        to: toAddress as `0x${string}`,
        value: parseEther(amount),
      };
      
      // å¦‚æœæœ‰é™„è¨€ï¼Œç¼–ç åˆ°dataå­—æ®µ
      if (message.trim()) {
        txParams.data = str2hex(message.trim()) as `0x${string}`;
      }
      
      // å‘é€äº¤æ˜“
      await sendTransaction(txParams);
    } catch (error) {
      console.error('Transfer error:', error);
      setIsTransferring(false);
    }
  };

  // ç›‘å¬äº¤æ˜“æˆåŠŸ
  useEffect(() => {
    if (isSuccess && hash) {
      onTransactionSuccess?.(hash);
    }
  }, [isSuccess, hash, onTransactionSuccess]);

  return (
    <div>
      {/* é’±åŒ…è¿æ¥UI */}
      {/* è½¬è´¦è¡¨å•UI */}
      {/* äº¤æ˜“çŠ¶æ€UI */}
    </div>
  )
}
```

### ğŸ’¡ å­¦ä¹ è¦ç‚¹

- **useAccount**: è·å–å½“å‰è¿æ¥çš„è´¦æˆ·ä¿¡æ¯
- **useConnect**: å¤„ç†é’±åŒ…è¿æ¥
- **useBalance**: æŸ¥è¯¢è´¦æˆ·ä½™é¢
- **useSendTransaction**: å‘é€äº¤æ˜“
- **useWaitForTransactionReceipt**: ç­‰å¾…äº¤æ˜“ç¡®è®¤

---

## ğŸ” GraphQL - æŸ¥è¯¢è¯­è¨€

### ğŸ¤” ä»€ä¹ˆæ˜¯ GraphQLï¼Ÿ

GraphQL æ˜¯ä¸€ç§ç”¨äº API çš„æŸ¥è¯¢è¯­è¨€å’Œè¿è¡Œæ—¶ç¯å¢ƒï¼Œè®©ä½ å¯ä»¥ç²¾ç¡®åœ°è¯·æ±‚ä½ éœ€è¦çš„æ•°æ®ã€‚

**ç®€å•ç†è§£**ï¼šå°±åƒåœ¨é¤å…ç‚¹èœï¼Œä½ å¯ä»¥ç²¾ç¡®åœ°è¯´è¦ä»€ä¹ˆï¼Œè€Œä¸æ˜¯åªèƒ½é€‰æ‹©å¥—é¤ã€‚

### ğŸ†š GraphQL vs REST API

#### REST APIï¼ˆä¼ ç»Ÿæ–¹å¼ï¼‰
```javascript
// éœ€è¦å¤šä¸ªè¯·æ±‚è·å–å®Œæ•´ä¿¡æ¯
const user = await fetch('/api/users/123')
const posts = await fetch('/api/users/123/posts') 
const comments = await fetch('/api/posts/456/comments')

// é—®é¢˜ï¼š
// 1. å¤šä¸ªè¯·æ±‚ï¼Œå»¶è¿Ÿé«˜
// 2. è¿”å›æ•°æ®å¯èƒ½åŒ…å«ä¸éœ€è¦çš„å­—æ®µ
// 3. éœ€è¦å¤šä¸ªç«¯ç‚¹
```

#### GraphQLï¼ˆæ–°æ–¹å¼ï¼‰
```javascript
// ä¸€ä¸ªè¯·æ±‚è·å–æ‰€æœ‰éœ€è¦çš„æ•°æ®
const { data } = await apolloClient.query({
  query: gql`
    query GetUserInfo($userId: ID!) {
      user(id: $userId) {
        name
        email
        posts(first: 10) {
          title
          content
          comments(first: 5) {
            text
            author
          }
        }
      }
    }
  `,
  variables: { userId: "123" }
})

// ä¼˜åŠ¿ï¼š
// 1. ä¸€ä¸ªè¯·æ±‚æå®š
// 2. åªè¿”å›éœ€è¦çš„å­—æ®µ
// 3. ç±»å‹å®‰å…¨
```

### ğŸ—ï¸ GraphQL æŸ¥è¯¢ç»“æ„

#### 1. åŸºæœ¬æŸ¥è¯¢
```graphql
# æŸ¥è¯¢è¯­æ³•
query {
  transferRecords {    # æŸ¥è¯¢è½¬è´¦è®°å½•
    id                 # è¿”å›IDå­—æ®µ
    value             # è¿”å›é‡‘é¢å­—æ®µ
    timestamp         # è¿”å›æ—¶é—´æˆ³å­—æ®µ
  }
}
```

#### 2. å¸¦å‚æ•°æŸ¥è¯¢
```graphql
# æ ¹æ®æ¡ä»¶ç­›é€‰
query GetTransactionsByAddress($userAddress: Bytes!) {
  transferRecords(
    where: { from: $userAddress }  # WHEREæ¡ä»¶
    first: 10                      # é™åˆ¶è¿”å›10æ¡
    orderBy: timestamp             # æŒ‰æ—¶é—´æ’åº
    orderDirection: desc           # é™åº
  ) {
    id
    from { address }
    to { address }
    value
    message
    timestamp
  }
}
```

#### 3. åµŒå¥—æŸ¥è¯¢
```graphql
# æŸ¥è¯¢è´¦æˆ·åŠå…¶ç›¸å…³çš„è½¬è´¦è®°å½•
query GetAccountDetails($accountId: ID!) {
  account(id: $accountId) {
    address
    recordCount
    transferRecordsSent {      # å‘é€çš„è®°å½•
      id
      to { address }
      value
      timestamp
    }
    transferRecordsReceived {  # æ¥æ”¶çš„è®°å½•
      id
      from { address }
      value
      timestamp
    }
  }
}
```

### ğŸ”§ åœ¨é¡¹ç›®ä¸­çš„ä½¿ç”¨

**æ–‡ä»¶ä½ç½®**: `frontend/src/hooks/useTransactionQuery.ts`

```typescript
import { useQuery } from '@apollo/client/react';
import { gql } from '@apollo/client';

// GraphQLæŸ¥è¯¢å®šä¹‰
export const GET_TRANSACTIONS = gql`
  query GetTransactions($first: Int = 10, $skip: Int = 0) {
    transferRecords(
      first: $first, 
      skip: $skip, 
      orderBy: blockNumber, 
      orderDirection: desc
    ) {
      id
      recordId
      from {
        address
      }
      to {
        address
      }
      value
      message
      timestamp
      blockNumber
      transactionHash
    }
  }
`;

// React Hookå°è£…
export const useTransactionsQuery = (first: number = 10, skip: number = 0, enabled: boolean = true) => {
  return useQuery<TransactionsData>(GET_TRANSACTIONS, {
    variables: { first, skip },
    skip: !enabled,  // æ¡ä»¶æŸ¥è¯¢æ§åˆ¶
    pollInterval: 30000, // æ¯30ç§’è‡ªåŠ¨åˆ·æ–°
  });
};
```

**æ–‡ä»¶ä½ç½®**: `frontend/src/components/TransactionList.tsx`

```typescript
const TransactionList: React.FC = () => {
  // ä½¿ç”¨GraphQL Hook
  const { data, loading, error } = useTransactionsQuery(20, 0, true);
  const { data: metaData } = useMetaQuery(true);

  if (loading) return <p>åŠ è½½æœ€æ–°äº¤æ˜“ä¸­...</p>;
  
  if (error) return (
    <div style={{ color: 'red' }}>
      GraphQLæŸ¥è¯¢é”™è¯¯: {error.message}
    </div>
  );

  return (
    <div>
      {/* æ˜¾ç¤ºThe GraphåŒæ­¥çŠ¶æ€ */}
      {metaData && (
        <div>
          å½“å‰åŒæ­¥åŒºå—: #{metaData._meta.block.number}
        </div>
      )}
      
      {/* æ˜¾ç¤ºè½¬è´¦è®°å½• */}
      {data?.transferRecords?.map((tx) => (
        <div key={tx.id}>
          <p>ä» {tx.from.address} åˆ° {tx.to.address}</p>
          <p>é‡‘é¢: {formatEther(tx.value)} ETH</p>
          <p>é™„è¨€: {tx.message}</p>
          <p>æ—¶é—´: {formatTimestamp(tx.timestamp)}</p>
        </div>
      ))}
    </div>
  );
};
```

### ğŸ’¡ å­¦ä¹ è¦ç‚¹

- **Query**: è¯»å–æ•°æ®æ“ä½œ
- **Variables**: æŸ¥è¯¢å‚æ•°ï¼Œæé«˜å¤ç”¨æ€§
- **Fragment**: æŸ¥è¯¢ç‰‡æ®µï¼Œé¿å…é‡å¤
- **Subscription**: å®æ—¶æ•°æ®è®¢é˜…ï¼ˆé«˜çº§ç”¨æ³•ï¼‰

---

## âš¡ Viem - ç°ä»£ä»¥å¤ªåŠåº“

### ğŸ¤” ä»€ä¹ˆæ˜¯ Viemï¼Ÿ

Viem æ˜¯ä¸€ä¸ªç°ä»£åŒ–çš„ TypeScript ä»¥å¤ªåŠåº“ï¼Œæä¾›ç±»å‹å®‰å…¨çš„åŒºå—é“¾äº¤äº’æ¥å£ã€‚

**ç®€å•ç†è§£**ï¼šViem æ˜¯ Ethers.js çš„ç°ä»£åŒ–æ›¿ä»£å“ï¼Œæ›´å¿«ã€æ›´å®‰å…¨ã€æ›´å¥½çš„ TypeScript æ”¯æŒã€‚

### ğŸ†š Viem vs Ethers.js

#### ä¼ ç»Ÿ Ethers.js
```javascript
import { ethers } from 'ethers';

// éœ€è¦æ‰‹åŠ¨å¤„ç†ç±»å‹è½¬æ¢
const provider = new ethers.JsonRpcProvider('...');
const balance = await provider.getBalance(address);
const ethBalance = ethers.formatEther(balance); // æ‰‹åŠ¨æ ¼å¼åŒ–
```

#### ç°ä»£ Viem
```typescript
import { createPublicClient, http, formatEther } from 'viem';
import { sepolia } from 'viem/chains';

// è‡ªåŠ¨ç±»å‹æ¨æ–­ï¼Œæ›´å¥½çš„TypeScriptæ”¯æŒ
const client = createPublicClient({
  chain: sepolia,
  transport: http()
});

const balance = await client.getBalance({ address }); // å®Œæ•´ç±»å‹å®‰å…¨
const ethBalance = formatEther(balance); // è‡ªåŠ¨ç±»å‹æ¨æ–­
```

### ğŸ”§ æ ¸å¿ƒåŠŸèƒ½

#### 1. ğŸ¦ åˆ›å»ºå®¢æˆ·ç«¯
```typescript
import { createPublicClient, createWalletClient, http } from 'viem'
import { sepolia } from 'viem/chains'

// å…¬å…±å®¢æˆ·ç«¯ï¼ˆåªè¯»æ“ä½œï¼‰
const publicClient = createPublicClient({
  chain: sepolia,
  transport: http('https://ethereum-sepolia-rpc.publicnode.com')
})

// é’±åŒ…å®¢æˆ·ç«¯ï¼ˆå¯å‘é€äº¤æ˜“ï¼‰
const walletClient = createWalletClient({
  chain: sepolia,
  transport: http()
})
```

#### 2. ğŸ“Š è¯»å–åŒºå—é“¾æ•°æ®
```typescript
// æŸ¥è¯¢ä½™é¢
const balance = await publicClient.getBalance({ 
  address: '0x...' 
})

// æŸ¥è¯¢åŒºå—ä¿¡æ¯
const block = await publicClient.getBlock({ 
  blockNumber: 123456n 
})

// æŸ¥è¯¢äº¤æ˜“
const transaction = await publicClient.getTransaction({ 
  hash: '0x...' 
})

// æŸ¥è¯¢äº¤æ˜“æ”¶æ®
const receipt = await publicClient.getTransactionReceipt({ 
  hash: '0x...' 
})
```

#### 3. ğŸ’¸ å‘é€äº¤æ˜“
```typescript
import { parseEther } from 'viem'

// å‘é€ETH
const hash = await walletClient.sendTransaction({
  to: '0x...',
  value: parseEther('0.1'), // 0.1 ETH
  data: '0x1234' // å¯é€‰çš„äº¤æ˜“æ•°æ®
})

// ç­‰å¾…äº¤æ˜“ç¡®è®¤
const receipt = await publicClient.waitForTransactionReceipt({ 
  hash 
})
```

#### 4. ğŸ“œ æ™ºèƒ½åˆçº¦äº¤äº’
```typescript
// è¯»å–åˆçº¦çŠ¶æ€
const result = await publicClient.readContract({
  address: '0xåˆçº¦åœ°å€',
  abi: contractAbi,
  functionName: 'balanceOf',
  args: ['0xç”¨æˆ·åœ°å€']
})

// è°ƒç”¨åˆçº¦æ–¹æ³•
const hash = await walletClient.writeContract({
  address: '0xåˆçº¦åœ°å€',
  abi: contractAbi,
  functionName: 'transfer',
  args: ['0xæ¥æ”¶æ–¹', parseUnits('100', 18)]
})
```

### ğŸ—ï¸ åœ¨é¡¹ç›®ä¸­çš„é›†æˆ

#### ä¸ Wagmi çš„å…³ç³»
```typescript
// Wagmi å†…éƒ¨ä½¿ç”¨ Viem
import { useAccount, useSendTransaction } from 'wagmi'
import { parseEther } from 'viem' // ç›´æ¥ä½¿ç”¨Viemå·¥å…·å‡½æ•°

function TransferComponent() {
  const { sendTransaction } = useSendTransaction()
  
  const handleSend = () => {
    sendTransaction({
      to: '0x...',
      value: parseEther('0.1') // Viemçš„ç±»å‹å®‰å…¨å‡½æ•°
    })
  }
  
  return <button onClick={handleSend}>å‘é€</button>
}
```

#### ç±»å‹å®‰å…¨çš„å¥½å¤„
```typescript
// Viemæä¾›å®Œæ•´çš„TypeScriptç±»å‹
import { Address, Hash, parseEther, formatEther } from 'viem'

interface TransferParams {
  to: Address;        // è‡ªåŠ¨éªŒè¯åœ°å€æ ¼å¼
  amount: string;     // ETHé‡‘é¢å­—ç¬¦ä¸²
  data?: Hash;        // å¯é€‰çš„äº¤æ˜“æ•°æ®
}

function createTransfer(params: TransferParams) {
  return {
    to: params.to,
    value: parseEther(params.amount), // è‡ªåŠ¨è½¬æ¢ä¸ºbigint
    data: params.data
  }
}
```

### ğŸ’¡ å­¦ä¹ è¦ç‚¹

- **Type Safety**: å®Œæ•´çš„TypeScriptç±»å‹æ”¯æŒ
- **Performance**: æ¯”Ethers.jsæ›´å¿«çš„æ‰§è¡Œé€Ÿåº¦  
- **Modern API**: æ›´ç®€æ´çš„APIè®¾è®¡
- **Tree Shaking**: åªæ‰“åŒ…ä½¿ç”¨çš„åŠŸèƒ½ï¼Œå‡å°åŒ…ä½“ç§¯

---

## ğŸ”„ æŠ€æœ¯æ ˆåä½œå…³ç³»

### ğŸ¯ æ•°æ®æµæ¶æ„å›¾

```mermaid
graph TB
    subgraph "å‰ç«¯å±‚"
        A[Reactç»„ä»¶] --> B[Wagmi Hooks]
        A --> C[Apollo Client]
    end
    
    subgraph "Web3äº¤äº’å±‚"
        B --> D[Viem]
        D --> E[MetaMaské’±åŒ…]
        D --> F[RPCèŠ‚ç‚¹]
    end
    
    subgraph "æ•°æ®å±‚"
        C --> G[GraphQLæŸ¥è¯¢]
        G --> H[The Graph API]
        H --> I[Subgraph]
        I --> J[æ™ºèƒ½åˆçº¦äº‹ä»¶]
    end
    
    subgraph "åŒºå—é“¾å±‚"
        E --> K[Sepoliaæµ‹è¯•ç½‘]
        F --> K
        J --> K
    end
    
    style A fill:#e3f2fd
    style H fill:#f3e5f5
    style K fill:#fff3e0
```

### ğŸ”— æŠ€æœ¯åä½œå…³ç³»

#### 1. ğŸ¨ å‰ç«¯UIå±‚
- **React**: ç»„ä»¶åŒ–UIæ¡†æ¶
- **TypeScript**: ç±»å‹å®‰å…¨å¼€å‘
- **Vite**: å¿«é€Ÿå¼€å‘æ„å»ºå·¥å…·

#### 2. ğŸŒ Web3é›†æˆå±‚
- **Wagmi**: æä¾›React Hooksï¼Œç®€åŒ–Web3æ“ä½œ
- **Viem**: åº•å±‚åŒºå—é“¾äº¤äº’ï¼Œç±»å‹å®‰å…¨
- **MetaMask**: ç”¨æˆ·é’±åŒ…è¿æ¥

#### 3. ğŸ“Š æ•°æ®æŸ¥è¯¢å±‚
- **Apollo Client**: GraphQLå®¢æˆ·ç«¯ï¼ŒçŠ¶æ€ç®¡ç†
- **GraphQL**: æŸ¥è¯¢è¯­è¨€ï¼Œç²¾ç¡®è·å–æ•°æ®
- **The Graph**: å»ä¸­å¿ƒåŒ–æ•°æ®ç´¢å¼•

#### 4. â›“ï¸ åŒºå—é“¾å±‚
- **Smart Contract**: ä¸šåŠ¡é€»è¾‘æ‰§è¡Œ
- **Sepolia**: ä»¥å¤ªåŠæµ‹è¯•ç½‘ç»œ
- **RPC**: åŒºå—é“¾èŠ‚ç‚¹é€šä¿¡åè®®

### ğŸ”„ å…¸å‹çš„ç”¨æˆ·æ“ä½œæµç¨‹

#### ğŸ’° å‘é€è½¬è´¦æ“ä½œ
```typescript
// 1. ç”¨æˆ·åœ¨Reactç»„ä»¶ä¸­æ“ä½œ
function TransferForm() {
  // 2. ä½¿ç”¨Wagmi Hookç®¡ç†çŠ¶æ€
  const { sendTransaction } = useSendTransaction()
  const { address } = useAccount()
  
  const handleTransfer = async () => {
    // 3. è°ƒç”¨Viemè¿›è¡Œç±»å‹å®‰å…¨çš„äº¤æ˜“æ„å»º
    await sendTransaction({
      to: toAddress as Address,
      value: parseEther(amount),
      data: str2hex(message) as Hash
    })
  }
  
  // 4. MetaMaskå¤„ç†ç­¾åå’Œå¹¿æ’­
  // 5. äº¤æ˜“ä¸Šé“¾åˆ°Sepoliaç½‘ç»œ
  // 6. æ™ºèƒ½åˆçº¦æ‰§è¡Œå¹¶è§¦å‘äº‹ä»¶
  // 7. The Graphç›‘å¬äº‹ä»¶å¹¶æ›´æ–°ç´¢å¼•
}
```

#### ğŸ” æŸ¥è¯¢äº¤æ˜“æ•°æ®
```typescript
function TransactionQuery() {
  // 1. ä½¿ç”¨Apollo Client + GraphQLæŸ¥è¯¢
  const { data } = useQuery(gql`
    query GetTransactions {
      transferRecords {
        id
        from { address }
        to { address }
        value
        message
      }
    }
  `)
  
  // 2. The Graphè¿”å›ç»“æ„åŒ–æ•°æ®
  // 3. Reactç»„ä»¶æ¸²æŸ“ç»“æœ
  return (
    <div>
      {data?.transferRecords?.map(tx => (
        <div key={tx.id}>
          {/* 4. æ˜¾ç¤ºå®Œæ•´åœ°å€å’Œæ ¼å¼åŒ–æ•°æ® */}
          <p>{tx.from.address} â†’ {tx.to.address}</p>
          <p>{formatEther(tx.value)} ETH</p>
        </div>
      ))}
    </div>
  )
}
```

### ğŸ“š å­¦ä¹ å»ºè®®

1. **ğŸš€ å…¥é—¨é¡ºåº**ï¼š
   - ReactåŸºç¡€ â†’ TypeScript â†’ ViemåŸºç¡€ â†’ Wagmi â†’ GraphQL â†’ The Graph

2. **ğŸ› ï¸ å®è·µæ–¹æ³•**ï¼š
   - å…ˆç†è§£æ¯ä¸ªæŠ€æœ¯çš„å•ç‹¬ä½œç”¨
   - ç„¶åç†è§£å®ƒä»¬å¦‚ä½•åä½œ
   - æœ€åé€šè¿‡é¡¹ç›®å®è·µæŒæ¡

3. **ğŸ“– é‡ç‚¹èµ„æº**ï¼š
   - [Wagmiå®˜æ–¹æ–‡æ¡£](https://wagmi.sh/)
   - [Viemå®˜æ–¹æ–‡æ¡£](https://viem.sh/) 
   - [The Graphæ–‡æ¡£](https://thegraph.com/docs/)
   - [GraphQLå­¦ä¹ æŒ‡å—](https://graphql.org/learn/)

---

## ğŸ¯ æ€»ç»“

æ¯ä¸ªæŠ€æœ¯éƒ½æœ‰å…¶ç‰¹å®šçš„ä½œç”¨ï¼š

- **ğŸ”— Ethers.js/Viem**: ä¸åŒºå—é“¾ç›´æ¥é€šä¿¡çš„æ¡¥æ¢
- **ğŸ“Š The Graph**: è®©å¤æ‚æ•°æ®æŸ¥è¯¢å˜å¾—ç®€å•å¿«é€Ÿ  
- **âš›ï¸ Wagmi**: è®©Reactå¼€å‘è€…è½»æ¾ä½¿ç”¨Web3åŠŸèƒ½
- **ğŸ” GraphQL**: ç²¾ç¡®æŸ¥è¯¢éœ€è¦çš„æ•°æ®ï¼Œé¿å…è¿‡åº¦è·å–
- **âš¡ Viem**: ç°ä»£åŒ–ã€ç±»å‹å®‰å…¨çš„åŒºå—é“¾äº¤äº’

æŒæ¡è¿™äº›æŠ€æœ¯ï¼Œä½ å°±èƒ½æ„å»ºå®Œæ•´çš„Web3åº”ç”¨ï¼ğŸš€