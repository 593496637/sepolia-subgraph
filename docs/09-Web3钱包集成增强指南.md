# 🔗 Web3 钱包集成增强指南

> 🎯 **全面指南**：从基础连接到高级功能的完整钱包集成方案

## 📋 指南概览

本指南将深入介绍 Web3 钱包集成的方方面面，包括：
- 🔌 多钱包支持和连接管理
- 💼 账户状态和余额监控
- 📝 交易签名和发送流程
- 🔐 安全最佳实践
- 🚀 高级功能实现

---

## 🌟 第一部分：钱包生态概览

### 1.1 主流钱包类型

| 钱包类型 | 代表产品 | 特点 | 集成难度 | 用户占比 |
|----------|----------|------|----------|----------|
| **浏览器扩展** | MetaMask, Coinbase Wallet | 功能丰富、安全性高 | 简单 | 70% |
| **移动端钱包** | Trust Wallet, imToken | 移动体验好 | 中等 | 20% |
| **硬件钱包** | Ledger, Trezor | 最高安全性 | 复杂 | 5% |
| **Web钱包** | WalletConnect | 跨平台兼容 | 简单 | 5% |

### 1.2 技术选择对比

```typescript
// 不同钱包库对比
interface WalletLibrary {
  name: string;
  features: string[];
  pros: string[];
  cons: string[];
  recommend: boolean;
}

const walletLibraries: WalletLibrary[] = [
  {
    name: "Wagmi",
    features: ["React hooks", "TypeScript支持", "自动类型推断", "缓存管理"],
    pros: ["现代化API", "强类型", "社区活跃", "文档完善"],
    cons: ["只支持React", "学习曲线"],
    recommend: true
  },
  {
    name: "Web3Modal",
    features: ["多钱包支持", "UI组件", "移动端适配"],
    pros: ["易于集成", "UI美观", "跨框架"],
    cons: ["定制性有限", "依赖较多"],
    recommend: true
  },
  {
    name: "Ethers.js + 手动集成",
    features: ["完全控制", "轻量级"],
    pros: ["灵活性高", "包体积小"],
    cons: ["开发复杂", "需要处理兼容性"],
    recommend: false
  }
];
```

---

## 🔧 第二部分：Wagmi 深度配置

### 2.1 高级配置选项

```typescript
// config/wagmi-advanced.ts
import { createConfig, http, webSocket } from 'wagmi';
import { 
  mainnet, 
  sepolia, 
  polygon, 
  arbitrum 
} from 'wagmi/chains';
import {
  metaMask,
  walletConnect,
  coinbaseWallet,
  injected
} from 'wagmi/connectors';
import { createStorage } from 'wagmi';

// 自定义链配置
const customChains = [
  sepolia,
  // 添加自定义网络
  {
    id: 31337,
    name: 'Localhost',
    network: 'localhost',
    nativeCurrency: {
      decimals: 18,
      name: 'Ethereum',
      symbol: 'ETH',
    },
    rpcUrls: {
      default: { http: ['http://127.0.0.1:8545'] },
      public: { http: ['http://127.0.0.1:8545'] },
    },
    blockExplorers: {
      default: { name: 'Local', url: 'http://localhost:8545' },
    },
  }
] as const;

// 连接器配置
const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID!;

const connectors = [
  // MetaMask 配置
  metaMask({
    dappMetadata: {
      name: 'Sepolia Web3 Explorer',
      url: 'https://your-domain.com',
      iconUrl: 'https://your-domain.com/icon.png'
    }
  }),

  // WalletConnect 配置
  walletConnect({
    projectId,
    metadata: {
      name: 'Sepolia Web3 Explorer',
      description: 'Explore Ethereum transactions with dual data sources',
      url: 'https://your-domain.com',
      icons: ['https://your-domain.com/icon.png']
    },
    // 支持的链
    chains: customChains,
    // 显示的钱包
    showQrModal: true,
    qrModalOptions: {
      themeMode: 'light',
      themeVariables: {
        '--wcm-z-index': '1000'
      }
    }
  }),

  // Coinbase Wallet
  coinbaseWallet({
    appName: 'Sepolia Web3 Explorer',
    appLogoUrl: 'https://your-domain.com/icon.png',
    preference: 'smartWalletOnly' // 优先使用智能钱包
  }),

  // 注入式钱包检测
  injected({
    // 自定义注入式钱包检测
    shimDisconnect: true,
  })
];

// 传输配置
const transports = {
  [sepolia.id]: http('https://rpc.sepolia.org', {
    // 请求超时
    timeout: 10000,
    // 批量请求
    batch: true,
    // 重试配置
    retryCount: 3,
    retryDelay: 1000
  }),
  // WebSocket 支持（用于事件监听）
  [mainnet.id]: webSocket('wss://eth-mainnet.ws.alchemyapi.io/v2/your-key'),
  // 本地开发
  [31337]: http('http://127.0.0.1:8545')
};

// 存储配置
const storage = createStorage({
  storage: typeof window !== 'undefined' ? localStorage : undefined,
  key: 'wagmi',
});

export const wagmiConfig = createConfig({
  chains: customChains,
  connectors,
  transports,
  storage,
  // SSR 支持
  ssr: false,
  // 同步外部连接器状态
  syncConnectedChain: true,
  // 多连接器支持
  multiInjectedProviderDiscovery: true
});

// 类型增强
declare module 'wagmi' {
  interface Register {
    config: typeof wagmiConfig;
  }
}
```

### 2.2 高级 Hook 封装

```typescript
// hooks/useAdvancedWallet.ts
import { 
  useAccount, 
  useBalance, 
  useConnect, 
  useDisconnect,
  useChainId,
  useSwitchChain,
  useEnsName,
  useEnsAvatar
} from 'wagmi';
import { useCallback, useEffect, useState } from 'react';
import { formatEther } from 'viem';

interface WalletState {
  // 连接状态
  isConnected: boolean;
  isConnecting: boolean;
  isDisconnecting: boolean;
  
  // 账户信息
  address?: `0x${string}`;
  ensName?: string;
  ensAvatar?: string;
  
  // 余额信息
  balance?: {
    value: bigint;
    formatted: string;
    symbol: string;
  };
  
  // 网络信息
  chainId?: number;
  chainName?: string;
  
  // 操作方法
  connect: (connectorId?: string) => Promise<void>;
  disconnect: () => Promise<void>;
  switchNetwork: (chainId: number) => Promise<void>;
  
  // 错误信息
  error?: Error;
}

export const useAdvancedWallet = (): WalletState => {
  const [error, setError] = useState<Error>();
  
  const { address, isConnected, connector } = useAccount();
  const { connect: wagmiConnect, connectors, isPending: isConnecting } = useConnect();
  const { disconnect: wagmiDisconnect, isPending: isDisconnecting } = useDisconnect();
  const chainId = useChainId();
  const { switchChain } = useSwitchChain();
  
  // ENS 信息
  const { data: ensName } = useEnsName({ 
    address,
    chainId: 1, // 主网 ENS
  });
  
  const { data: ensAvatar } = useEnsAvatar({ 
    name: ensName!,
    chainId: 1,
  });

  // 余额信息
  const { data: balanceData, refetch: refetchBalance } = useBalance({
    address,
    query: {
      enabled: !!address,
      refetchInterval: 10000, // 10秒更新一次
    }
  });

  // 连接钱包
  const connect = useCallback(async (connectorId?: string) => {
    try {
      setError(undefined);
      
      let selectedConnector = connectors[0]; // 默认第一个
      
      if (connectorId) {
        selectedConnector = connectors.find(c => c.id === connectorId) || connectors[0];
      }
      
      await wagmiConnect({ connector: selectedConnector });
    } catch (err) {
      setError(err as Error);
    }
  }, [wagmiConnect, connectors]);

  // 断开连接
  const disconnect = useCallback(async () => {
    try {
      setError(undefined);
      await wagmiDisconnect();
    } catch (err) {
      setError(err as Error);
    }
  }, [wagmiDisconnect]);

  // 切换网络
  const switchNetwork = useCallback(async (targetChainId: number) => {
    try {
      setError(undefined);
      await switchChain({ chainId: targetChainId });
    } catch (err) {
      setError(err as Error);
    }
  }, [switchChain]);

  // 监听账户变化
  useEffect(() => {
    if (isConnected && address) {
      refetchBalance();
    }
  }, [isConnected, address, refetchBalance]);

  return {
    isConnected,
    isConnecting,
    isDisconnecting,
    address,
    ensName: ensName || undefined,
    ensAvatar: ensAvatar || undefined,
    balance: balanceData ? {
      value: balanceData.value,
      formatted: formatEther(balanceData.value),
      symbol: balanceData.symbol
    } : undefined,
    chainId,
    chainName: connector?.chains?.find(c => c.id === chainId)?.name,
    connect,
    disconnect,
    switchNetwork,
    error
  };
};
```

### 2.3 智能合约交互封装

```typescript
// hooks/useSmartContract.ts
import { 
  useReadContract, 
  useWriteContract, 
  useWaitForTransactionReceipt,
  useWatchContractEvent
} from 'wagmi';
import { useCallback, useState } from 'react';
import { Abi, Address } from 'viem';

interface ContractConfig {
  address: Address;
  abi: Abi;
  chainId?: number;
}

interface WriteResult {
  hash?: `0x${string}`;
  isLoading: boolean;
  isSuccess: boolean;
  error?: Error;
  write: (args?: unknown[]) => Promise<void>;
}

export const useSmartContract = (config: ContractConfig) => {
  const [writeState, setWriteState] = useState<{
    hash?: `0x${string}`;
    isLoading: boolean;
    isSuccess: boolean;
    error?: Error;
  }>({
    isLoading: false,
    isSuccess: false
  });

  const { writeContract } = useWriteContract();

  // 读取合约
  const useContractRead = (functionName: string, args?: unknown[]) => {
    return useReadContract({
      ...config,
      functionName,
      args: args || []
    });
  };

  // 写入合约
  const useContractWrite = (functionName: string): WriteResult => {
    const write = useCallback(async (args?: unknown[]) => {
      try {
        setWriteState({ isLoading: true, isSuccess: false });
        
        const hash = await writeContract({
          ...config,
          functionName,
          args: args || []
        });

        setWriteState({ 
          hash, 
          isLoading: false, 
          isSuccess: true 
        });
      } catch (error) {
        setWriteState({ 
          isLoading: false, 
          isSuccess: false,
          error: error as Error 
        });
      }
    }, [functionName]);

    return {
      ...writeState,
      write
    };
  };

  // 监听合约事件
  const useWatchEvent = (
    eventName: string,
    onLogs: (logs: any[]) => void
  ) => {
    return useWatchContractEvent({
      ...config,
      eventName,
      onLogs,
      poll: true,
      pollingInterval: 1000
    });
  };

  // 等待交易确认
  const useWaitForTx = (hash?: `0x${string}`) => {
    return useWaitForTransactionReceipt({
      hash,
      query: {
        enabled: !!hash,
      }
    });
  };

  return {
    useContractRead,
    useContractWrite,
    useWatchEvent,
    useWaitForTx
  };
};
```

---

## 💼 第三部分：多钱包管理系统

### 3.1 钱包管理器实现

```typescript
// services/WalletManager.ts
export class WalletManager {
  private static instance: WalletManager;
  private supportedWallets: Map<string, WalletInfo> = new Map();
  private currentWallet?: WalletInfo;
  private eventEmitter = new EventTarget();

  static getInstance() {
    if (!WalletManager.instance) {
      WalletManager.instance = new WalletManager();
    }
    return WalletManager.instance;
  }

  constructor() {
    this.initializeSupportedWallets();
    this.detectInstalledWallets();
  }

  private initializeSupportedWallets() {
    const wallets: WalletInfo[] = [
      {
        id: 'metamask',
        name: 'MetaMask',
        icon: '/icons/metamask.svg',
        downloadUrl: 'https://metamask.io/download/',
        isInstalled: false,
        isDetectable: true,
        connector: 'metaMask'
      },
      {
        id: 'coinbase',
        name: 'Coinbase Wallet',
        icon: '/icons/coinbase.svg',
        downloadUrl: 'https://www.coinbase.com/wallet',
        isInstalled: false,
        isDetectable: true,
        connector: 'coinbaseWallet'
      },
      {
        id: 'walletconnect',
        name: 'WalletConnect',
        icon: '/icons/walletconnect.svg',
        downloadUrl: 'https://walletconnect.com/',
        isInstalled: true, // 总是可用
        isDetectable: false,
        connector: 'walletConnect'
      }
    ];

    wallets.forEach(wallet => {
      this.supportedWallets.set(wallet.id, wallet);
    });
  }

  private detectInstalledWallets() {
    // 检测 MetaMask
    if (typeof window !== 'undefined' && window.ethereum?.isMetaMask) {
      const metamask = this.supportedWallets.get('metamask');
      if (metamask) {
        metamask.isInstalled = true;
      }
    }

    // 检测 Coinbase Wallet
    if (typeof window !== 'undefined' && window.ethereum?.isCoinbaseWallet) {
      const coinbase = this.supportedWallets.get('coinbase');
      if (coinbase) {
        coinbase.isInstalled = true;
      }
    }

    // 检测其他注入式钱包
    this.detectOtherWallets();
  }

  private detectOtherWallets() {
    if (typeof window === 'undefined') return;

    const commonWallets = [
      { key: 'isTrust', name: 'Trust Wallet' },
      { key: 'isImToken', name: 'imToken' },
      { key: 'isBraveWallet', name: 'Brave Wallet' },
      { key: 'isRabby', name: 'Rabby' }
    ];

    commonWallets.forEach(({ key, name }) => {
      if (window.ethereum?.[key]) {
        this.supportedWallets.set(key.toLowerCase(), {
          id: key.toLowerCase(),
          name,
          icon: `/icons/${key.toLowerCase()}.svg`,
          downloadUrl: '',
          isInstalled: true,
          isDetectable: true,
          connector: 'injected'
        });
      }
    });
  }

  // 获取所有支持的钱包
  getSupportedWallets(): WalletInfo[] {
    return Array.from(this.supportedWallets.values());
  }

  // 获取已安装的钱包
  getInstalledWallets(): WalletInfo[] {
    return Array.from(this.supportedWallets.values())
      .filter(wallet => wallet.isInstalled);
  }

  // 推荐钱包排序
  getRecommendedWallets(): WalletInfo[] {
    const installed = this.getInstalledWallets();
    const notInstalled = Array.from(this.supportedWallets.values())
      .filter(wallet => !wallet.isInstalled);

    // 优先显示已安装的钱包
    return [...installed, ...notInstalled];
  }

  // 连接钱包
  async connectWallet(walletId: string): Promise<boolean> {
    const wallet = this.supportedWallets.get(walletId);
    if (!wallet) {
      throw new Error(`不支持的钱包: ${walletId}`);
    }

    if (!wallet.isInstalled && wallet.isDetectable) {
      throw new Error(`钱包未安装: ${wallet.name}`);
    }

    try {
      // 这里集成 Wagmi 的连接逻辑
      // 发送连接成功事件
      this.currentWallet = wallet;
      this.emitEvent('wallet-connected', { wallet });
      return true;
    } catch (error) {
      this.emitEvent('wallet-error', { error, wallet });
      throw error;
    }
  }

  // 断开连接
  async disconnectWallet(): Promise<void> {
    if (this.currentWallet) {
      const previousWallet = this.currentWallet;
      this.currentWallet = undefined;
      this.emitEvent('wallet-disconnected', { wallet: previousWallet });
    }
  }

  // 事件监听
  addEventListener(eventType: string, callback: (event: CustomEvent) => void) {
    this.eventEmitter.addEventListener(eventType, callback as EventListener);
  }

  private emitEvent(eventType: string, data: any) {
    const event = new CustomEvent(eventType, { detail: data });
    this.eventEmitter.dispatchEvent(event);
  }
}

interface WalletInfo {
  id: string;
  name: string;
  icon: string;
  downloadUrl: string;
  isInstalled: boolean;
  isDetectable: boolean;
  connector: string;
}
```

### 3.2 钱包选择组件

```tsx
// components/WalletModal.tsx
import React, { useState, useEffect } from 'react';
import { WalletManager } from '../services/WalletManager';
import { useAdvancedWallet } from '../hooks/useAdvancedWallet';

interface WalletModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConnect: (walletId: string) => void;
}

export const WalletModal: React.FC<WalletModalProps> = ({
  isOpen,
  onClose,
  onConnect
}) => {
  const [wallets, setWallets] = useState<WalletInfo[]>([]);
  const [connecting, setConnecting] = useState<string | null>(null);
  const { connect, error } = useAdvancedWallet();

  useEffect(() => {
    const walletManager = WalletManager.getInstance();
    setWallets(walletManager.getRecommendedWallets());
  }, []);

  const handleWalletClick = async (wallet: WalletInfo) => {
    if (!wallet.isInstalled && wallet.isDetectable) {
      window.open(wallet.downloadUrl, '_blank');
      return;
    }

    try {
      setConnecting(wallet.id);
      await connect(wallet.connector);
      onConnect(wallet.id);
      onClose();
    } catch (error) {
      console.error('连接失败:', error);
    } finally {
      setConnecting(null);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="wallet-modal-overlay" onClick={onClose}>
      <div className="wallet-modal" onClick={e => e.stopPropagation()}>
        <div className="modal-header">
          <h2>连接钱包</h2>
          <button onClick={onClose} className="close-button">×</button>
        </div>

        <div className="wallet-list">
          {wallets.map(wallet => (
            <button
              key={wallet.id}
              className={`wallet-item ${!wallet.isInstalled ? 'not-installed' : ''}`}
              onClick={() => handleWalletClick(wallet)}
              disabled={connecting === wallet.id}
            >
              <img src={wallet.icon} alt={wallet.name} className="wallet-icon" />
              <span className="wallet-name">{wallet.name}</span>
              
              {connecting === wallet.id && (
                <div className="spinner" />
              )}
              
              {!wallet.isInstalled && wallet.isDetectable && (
                <span className="install-badge">安装</span>
              )}
              
              {wallet.isInstalled && (
                <span className="installed-badge">已安装</span>
              )}
            </button>
          ))}
        </div>

        {error && (
          <div className="error-message">
            连接失败: {error.message}
          </div>
        )}

        <div className="modal-footer">
          <p>
            连接钱包即表示您同意我们的
            <a href="/terms" target="_blank">服务条款</a>和
            <a href="/privacy" target="_blank">隐私政策</a>
          </p>
        </div>
      </div>
    </div>
  );
};
```

---

## 🔐 第四部分：安全最佳实践

### 4.1 签名验证系统

```typescript
// utils/signatureVerification.ts
import { verifyMessage, recoverMessageAddress } from 'viem';

export class SignatureVerificationService {
  
  // 创建签名消息
  static createSignMessage(
    action: string, 
    timestamp: number, 
    nonce: string,
    additionalData?: Record<string, any>
  ): string {
    const message = {
      action,
      timestamp,
      nonce,
      domain: window.location.origin,
      ...additionalData
    };

    return JSON.stringify(message, Object.keys(message).sort());
  }

  // 请求用户签名
  static async requestSignature(
    message: string,
    address: `0x${string}`,
    signMessage: (args: { message: string }) => Promise<`0x${string}`>
  ): Promise<`0x${string}`> {
    try {
      return await signMessage({ message });
    } catch (error) {
      console.error('签名失败:', error);
      throw new Error('用户拒绝签名');
    }
  }

  // 验证签名
  static async verifySignature(
    message: string,
    signature: `0x${string}`,
    expectedAddress: `0x${string}`
  ): Promise<boolean> {
    try {
      const recoveredAddress = await recoverMessageAddress({
        message,
        signature
      });

      return recoveredAddress.toLowerCase() === expectedAddress.toLowerCase();
    } catch (error) {
      console.error('签名验证失败:', error);
      return false;
    }
  }

  // 检查消息时效性
  static isMessageValid(
    message: string,
    maxAgeMinutes: number = 10
  ): boolean {
    try {
      const parsed = JSON.parse(message);
      const messageTime = new Date(parsed.timestamp);
      const now = new Date();
      const diffMinutes = (now.getTime() - messageTime.getTime()) / (1000 * 60);

      return diffMinutes <= maxAgeMinutes;
    } catch {
      return false;
    }
  }
}

// 使用示例
export const useMessageSigning = () => {
  const { signMessage } = useSignMessage();
  const { address } = useAdvancedWallet();

  const signAndVerify = async (action: string, data?: any) => {
    if (!address) throw new Error('钱包未连接');

    const timestamp = Date.now();
    const nonce = crypto.randomUUID();
    
    const message = SignatureVerificationService.createSignMessage(
      action, 
      timestamp, 
      nonce, 
      data
    );

    const signature = await SignatureVerificationService.requestSignature(
      message,
      address,
      signMessage
    );

    const isValid = await SignatureVerificationService.verifySignature(
      message,
      signature,
      address
    );

    if (!isValid) {
      throw new Error('签名验证失败');
    }

    return { message, signature, timestamp, nonce };
  };

  return { signAndVerify };
};
```

### 4.2 交易安全检查

```typescript
// services/TransactionSecurity.ts
export class TransactionSecurity {
  
  // 交易前安全检查
  static async performSecurityCheck(
    to: `0x${string}`,
    value: bigint,
    data?: `0x${string}`
  ): Promise<SecurityCheckResult> {
    const checks: SecurityCheck[] = [];

    // 1. 地址验证
    checks.push(await this.checkAddress(to));

    // 2. 金额合理性检查
    checks.push(await this.checkAmount(value));

    // 3. 合约安全检查
    if (data && data !== '0x') {
      checks.push(await this.checkContractInteraction(to, data));
    }

    // 4. 网络钓鱼检查
    checks.push(await this.checkPhishingSite());

    const highRiskChecks = checks.filter(c => c.risk === 'high');
    const mediumRiskChecks = checks.filter(c => c.risk === 'medium');

    return {
      isRecommended: highRiskChecks.length === 0,
      riskLevel: this.calculateOverallRisk(checks),
      checks,
      warnings: [...highRiskChecks, ...mediumRiskChecks].map(c => c.message)
    };
  }

  private static async checkAddress(address: `0x${string}`): Promise<SecurityCheck> {
    // 检查是否为已知恶意地址
    const maliciousAddresses = await this.getMaliciousAddresses();
    
    if (maliciousAddresses.includes(address.toLowerCase())) {
      return {
        type: 'address',
        risk: 'high',
        message: '警告：目标地址被标记为恶意地址！',
        passed: false
      };
    }

    // 检查是否为智能合约
    const code = await this.getCode(address);
    if (code && code !== '0x') {
      return {
        type: 'address',
        risk: 'medium',
        message: '目标地址是智能合约，请确认交互意图',
        passed: true
      };
    }

    return {
      type: 'address',
      risk: 'low',
      message: '地址验证通过',
      passed: true
    };
  }

  private static async checkAmount(value: bigint): Promise<SecurityCheck> {
    const ethValue = Number(value) / 1e18;
    
    if (ethValue > 10) {
      return {
        type: 'amount',
        risk: 'high',
        message: `高额转账警告：${ethValue.toFixed(4)} ETH`,
        passed: false
      };
    }

    if (ethValue > 1) {
      return {
        type: 'amount',
        risk: 'medium',
        message: `中等金额转账：${ethValue.toFixed(4)} ETH`,
        passed: true
      };
    }

    return {
      type: 'amount',
      risk: 'low',
      message: '转账金额正常',
      passed: true
    };
  }

  private static async checkContractInteraction(
    address: `0x${string}`,
    data: `0x${string}`
  ): Promise<SecurityCheck> {
    try {
      // 解析函数选择器
      const functionSelector = data.slice(0, 10);
      
      // 检查已知危险函数
      const dangerousFunctions = [
        '0xa9059cbb', // transfer
        '0x23b872dd', // transferFrom
        '0x095ea7b3', // approve
      ];

      if (dangerousFunctions.includes(functionSelector)) {
        return {
          type: 'contract',
          risk: 'medium',
          message: '正在调用代币转账相关函数，请确认操作',
          passed: true
        };
      }

      return {
        type: 'contract',
        risk: 'low',
        message: '合约交互安全检查通过',
        passed: true
      };
    } catch {
      return {
        type: 'contract',
        risk: 'medium',
        message: '无法解析合约调用数据',
        passed: true
      };
    }
  }

  private static async checkPhishingSite(): Promise<SecurityCheck> {
    const currentDomain = window.location.hostname;
    
    // 检查是否为已知钓鱼网站
    const phishingDomains = await this.getPhishingDomains();
    
    if (phishingDomains.includes(currentDomain)) {
      return {
        type: 'phishing',
        risk: 'high',
        message: '警告：当前网站可能是钓鱼网站！',
        passed: false
      };
    }

    return {
      type: 'phishing',
      risk: 'low',
      message: '网站安全检查通过',
      passed: true
    };
  }

  private static calculateOverallRisk(checks: SecurityCheck[]): 'low' | 'medium' | 'high' {
    const hasHigh = checks.some(c => c.risk === 'high');
    const hasMedium = checks.some(c => c.risk === 'medium');
    
    if (hasHigh) return 'high';
    if (hasMedium) return 'medium';
    return 'low';
  }

  // 模拟数据源，实际应用中应该从可信的API获取
  private static async getMaliciousAddresses(): Promise<string[]> {
    // 从安全服务获取恶意地址列表
    return [];
  }

  private static async getPhishingDomains(): Promise<string[]> {
    // 从安全服务获取钓鱼域名列表
    return [];
  }

  private static async getCode(address: `0x${string}`): Promise<`0x${string}` | null> {
    // 获取地址的字节码
    return null;
  }
}

interface SecurityCheck {
  type: 'address' | 'amount' | 'contract' | 'phishing';
  risk: 'low' | 'medium' | 'high';
  message: string;
  passed: boolean;
}

interface SecurityCheckResult {
  isRecommended: boolean;
  riskLevel: 'low' | 'medium' | 'high';
  checks: SecurityCheck[];
  warnings: string[];
}
```

---

## 📊 第五部分：用户体验优化

### 5.1 连接状态管理

```tsx
// components/WalletStatus.tsx
import React from 'react';
import { useAdvancedWallet } from '../hooks/useAdvancedWallet';

export const WalletStatus: React.FC = () => {
  const { 
    isConnected, 
    isConnecting, 
    address, 
    ensName,
    ensAvatar,
    balance, 
    chainName,
    disconnect,
    error 
  } = useAdvancedWallet();

  const formatAddress = (addr: string) => {
    return `${addr.slice(0, 6)}...${addr.slice(-4)}`;
  };

  if (isConnecting) {
    return (
      <div className="wallet-status connecting">
        <div className="spinner" />
        <span>连接中...</span>
      </div>
    );
  }

  if (!isConnected) {
    return (
      <div className="wallet-status disconnected">
        <span>未连接钱包</span>
      </div>
    );
  }

  if (error) {
    return (
      <div className="wallet-status error">
        <span>连接错误: {error.message}</span>
        <button onClick={() => window.location.reload()}>
          重试
        </button>
      </div>
    );
  }

  return (
    <div className="wallet-status connected">
      <div className="wallet-info">
        {ensAvatar && (
          <img src={ensAvatar} alt="Avatar" className="wallet-avatar" />
        )}
        <div className="wallet-details">
          <div className="wallet-address">
            {ensName || formatAddress(address!)}
          </div>
          <div className="wallet-balance">
            {balance?.formatted} {balance?.symbol}
          </div>
          <div className="wallet-network">
            {chainName}
          </div>
        </div>
      </div>
      <button onClick={disconnect} className="disconnect-button">
        断开
      </button>
    </div>
  );
};
```

### 5.2 交易状态跟踪

```tsx
// components/TransactionTracker.tsx
import React, { useEffect, useState } from 'react';
import { useWaitForTransactionReceipt } from 'wagmi';

interface TransactionTrackerProps {
  hash?: `0x${string}`;
  onSuccess?: (receipt: any) => void;
  onError?: (error: Error) => void;
}

export const TransactionTracker: React.FC<TransactionTrackerProps> = ({
  hash,
  onSuccess,
  onError
}) => {
  const [elapsedTime, setElapsedTime] = useState(0);
  const [startTime] = useState(Date.now());

  const { 
    data: receipt, 
    isLoading, 
    isSuccess, 
    error 
  } = useWaitForTransactionReceipt({
    hash,
    query: {
      enabled: !!hash,
    }
  });

  // 更新经过时间
  useEffect(() => {
    if (!isLoading) return;

    const timer = setInterval(() => {
      setElapsedTime(Math.floor((Date.now() - startTime) / 1000));
    }, 1000);

    return () => clearInterval(timer);
  }, [isLoading, startTime]);

  // 处理成功和错误
  useEffect(() => {
    if (isSuccess && receipt && onSuccess) {
      onSuccess(receipt);
    }
  }, [isSuccess, receipt, onSuccess]);

  useEffect(() => {
    if (error && onError) {
      onError(error);
    }
  }, [error, onError]);

  if (!hash) return null;

  const getStatusColor = () => {
    if (error) return '#f44336';
    if (isSuccess) return '#4caf50';
    return '#ff9800';
  };

  const getStatusText = () => {
    if (error) return '交易失败';
    if (isSuccess) return '交易成功';
    return '确认中...';
  };

  return (
    <div className="transaction-tracker">
      <div className="tracker-header">
        <div 
          className="status-indicator" 
          style={{ backgroundColor: getStatusColor() }}
        />
        <span className="status-text">{getStatusText()}</span>
      </div>

      <div className="tracker-details">
        <div className="detail-row">
          <span>交易哈希:</span>
          <a 
            href={`https://sepolia.etherscan.io/tx/${hash}`}
            target="_blank"
            rel="noopener noreferrer"
            className="tx-link"
          >
            {`${hash.slice(0, 10)}...${hash.slice(-8)}`}
          </a>
        </div>

        {isLoading && (
          <div className="detail-row">
            <span>等待时间:</span>
            <span>{elapsedTime}秒</span>
          </div>
        )}

        {receipt && (
          <>
            <div className="detail-row">
              <span>区块号:</span>
              <span>{receipt.blockNumber.toString()}</span>
            </div>
            <div className="detail-row">
              <span>Gas 使用:</span>
              <span>{receipt.gasUsed.toString()}</span>
            </div>
            <div className="detail-row">
              <span>交易费用:</span>
              <span>
                {((receipt.gasUsed * receipt.effectiveGasPrice) / 1e18).toFixed(6)} ETH
              </span>
            </div>
          </>
        )}

        {error && (
          <div className="detail-row error">
            <span>错误信息:</span>
            <span>{error.message}</span>
          </div>
        )}
      </div>

      {isLoading && (
        <div className="progress-bar">
          <div className="progress-fill" />
        </div>
      )}
    </div>
  );
};
```

### 5.3 网络切换提示

```tsx
// components/NetworkSwitcher.tsx
import React, { useState } from 'react';
import { useAdvancedWallet } from '../hooks/useAdvancedWallet';
import { sepolia, mainnet } from 'wagmi/chains';

const SUPPORTED_NETWORKS = [
  { ...sepolia, icon: '/icons/ethereum.svg' },
  { ...mainnet, icon: '/icons/ethereum.svg' }
];

export const NetworkSwitcher: React.FC = () => {
  const { chainId, switchNetwork, error } = useAdvancedWallet();
  const [isSwitching, setIsSwitching] = useState(false);

  const currentNetwork = SUPPORTED_NETWORKS.find(n => n.id === chainId);
  const isUnsupportedNetwork = !currentNetwork;

  const handleNetworkSwitch = async (targetChainId: number) => {
    try {
      setIsSwitching(true);
      await switchNetwork(targetChainId);
    } catch (err) {
      console.error('网络切换失败:', err);
    } finally {
      setIsSwitching(false);
    }
  };

  if (isUnsupportedNetwork) {
    return (
      <div className="network-switcher unsupported">
        <div className="warning-icon">⚠️</div>
        <div className="warning-text">
          <h3>不支持的网络</h3>
          <p>请切换到支持的网络以继续使用</p>
        </div>
        <div className="network-options">
          {SUPPORTED_NETWORKS.map(network => (
            <button
              key={network.id}
              onClick={() => handleNetworkSwitch(network.id)}
              disabled={isSwitching}
              className="network-button"
            >
              <img src={network.icon} alt={network.name} />
              <span>{network.name}</span>
            </button>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="network-switcher supported">
      <div className="current-network">
        <img src={currentNetwork.icon} alt={currentNetwork.name} />
        <span>{currentNetwork.name}</span>
        <div className="network-status connected">
          ● 已连接
        </div>
      </div>

      <div className="other-networks">
        {SUPPORTED_NETWORKS
          .filter(n => n.id !== chainId)
          .map(network => (
            <button
              key={network.id}
              onClick={() => handleNetworkSwitch(network.id)}
              disabled={isSwitching}
              className="network-option"
            >
              <img src={network.icon} alt={network.name} />
              <span>{network.name}</span>
            </button>
          ))
        }
      </div>

      {error && (
        <div className="error-message">
          网络切换失败: {error.message}
        </div>
      )}
    </div>
  );
};
```

---

## 📱 第六部分：移动端适配

### 6.1 响应式钱包连接

```tsx
// hooks/useMobileWallet.ts
import { useEffect, useState } from 'react';
import { useAdvancedWallet } from './useAdvancedWallet';

export const useMobileWallet = () => {
  const [isMobile, setIsMobile] = useState(false);
  const [isInAppBrowser, setIsInAppBrowser] = useState(false);
  const wallet = useAdvancedWallet();

  useEffect(() => {
    const checkMobile = () => {
      const isMobileDevice = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      setIsMobile(isMobileDevice);

      // 检查是否在应用内浏览器中
      const isInApp = /MetaMaskMobile|Trust|imToken|Coinbase/i.test(navigator.userAgent);
      setIsInAppBrowser(isInApp);
    };

    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const connectMobileWallet = async () => {
    if (isInAppBrowser) {
      // 直接连接注入的钱包
      return wallet.connect('injected');
    } else {
      // 使用 WalletConnect
      return wallet.connect('walletConnect');
    }
  };

  const openInWallet = (url: string, walletName: string) => {
    const walletUrls = {
      metamask: `https://metamask.app.link/dapp/${url}`,
      trust: `https://link.trustwallet.com/open_url?coin_id=60&url=${url}`,
      coinbase: `https://go.cb-w.com/dapp?cb_url=${url}`,
      imtoken: `imtokenv2://navigate/DApp?url=${url}`
    };

    const walletUrl = walletUrls[walletName as keyof typeof walletUrls];
    if (walletUrl) {
      window.location.href = walletUrl;
    }
  };

  return {
    isMobile,
    isInAppBrowser,
    connectMobileWallet,
    openInWallet,
    ...wallet
  };
};
```

### 6.2 移动端友好的钱包选择器

```tsx
// components/MobileWalletSelector.tsx
import React, { useState } from 'react';
import { useMobileWallet } from '../hooks/useMobileWallet';

export const MobileWalletSelector: React.FC = () => {
  const { 
    isMobile, 
    isInAppBrowser, 
    connectMobileWallet, 
    openInWallet,
    isConnected,
    isConnecting 
  } = useMobileWallet();

  const [selectedWallet, setSelectedWallet] = useState<string>('');

  if (!isMobile) {
    return null; // 使用桌面版钱包选择器
  }

  const mobileWallets = [
    { id: 'metamask', name: 'MetaMask', color: '#f6851b' },
    { id: 'trust', name: 'Trust Wallet', color: '#3375bb' },
    { id: 'coinbase', name: 'Coinbase Wallet', color: '#0052ff' },
    { id: 'imtoken', name: 'imToken', color: '#11c4d1' }
  ];

  const handleWalletSelect = async (walletId: string) => {
    setSelectedWallet(walletId);

    if (isInAppBrowser) {
      // 在钱包应用内，直接连接
      await connectMobileWallet();
    } else {
      // 在普通浏览器中，尝试打开钱包应用
      const currentUrl = window.location.href;
      openInWallet(currentUrl, walletId);
    }
  };

  return (
    <div className="mobile-wallet-selector">
      <h2>选择钱包</h2>
      
      {isInAppBrowser ? (
        <div className="in-app-browser">
          <p>检测到钱包应用环境</p>
          <button 
            onClick={connectMobileWallet}
            disabled={isConnecting}
            className="connect-button"
          >
            {isConnecting ? '连接中...' : '连接钱包'}
          </button>
        </div>
      ) : (
        <div className="wallet-grid">
          {mobileWallets.map(wallet => (
            <button
              key={wallet.id}
              onClick={() => handleWalletSelect(wallet.id)}
              disabled={isConnecting && selectedWallet === wallet.id}
              className="wallet-card"
              style={{ borderColor: wallet.color }}
            >
              <div 
                className="wallet-icon"
                style={{ backgroundColor: wallet.color }}
              >
                {wallet.name.charAt(0)}
              </div>
              <span className="wallet-name">{wallet.name}</span>
              {isConnecting && selectedWallet === wallet.id && (
                <div className="connecting">连接中...</div>
              )}
            </button>
          ))}
        </div>
      )}

      <div className="mobile-tips">
        <h3>移动端使用提示:</h3>
        <ul>
          <li>确保已安装对应的钱包应用</li>
          <li>首次连接可能需要在钱包中确认</li>
          <li>连接后返回浏览器继续操作</li>
        </ul>
      </div>
    </div>
  );
};
```

---

## 🔧 第七部分：高级功能实现

### 7.1 批量交易处理

```typescript
// services/BatchTransactionService.ts
interface BatchTransaction {
  to: `0x${string}`;
  value: bigint;
  data?: `0x${string}`;
  gasLimit?: bigint;
}

export class BatchTransactionService {
  
  static async executeBatchTransactions(
    transactions: BatchTransaction[],
    signer: any
  ): Promise<BatchTransactionResult> {
    const results: TransactionResult[] = [];
    let totalGasUsed = 0n;
    let totalValue = 0n;

    // 预检查所有交易
    for (const tx of transactions) {
      const check = await this.validateTransaction(tx, signer);
      if (!check.isValid) {
        return {
          success: false,
          error: `交易验证失败: ${check.error}`,
          results: []
        };
      }
    }

    // 执行交易
    for (let i = 0; i < transactions.length; i++) {
      const tx = transactions[i];
      
      try {
        console.log(`执行交易 ${i + 1}/${transactions.length}`);
        
        const txResponse = await signer.sendTransaction({
          to: tx.to,
          value: tx.value,
          data: tx.data,
          gasLimit: tx.gasLimit
        });

        const receipt = await txResponse.wait();
        
        results.push({
          index: i,
          hash: txResponse.hash,
          success: true,
          gasUsed: receipt.gasUsed,
          receipt
        });

        totalGasUsed += receipt.gasUsed;
        totalValue += tx.value;

      } catch (error) {
        results.push({
          index: i,
          hash: null,
          success: false,
          error: error.message,
          gasUsed: 0n
        });

        // 是否继续执行后续交易（可配置）
        const shouldContinue = await this.shouldContinueOnError(error, i, transactions.length);
        if (!shouldContinue) break;
      }
    }

    const successCount = results.filter(r => r.success).length;
    
    return {
      success: successCount === transactions.length,
      results,
      summary: {
        total: transactions.length,
        successful: successCount,
        failed: transactions.length - successCount,
        totalGasUsed,
        totalValue
      }
    };
  }

  private static async validateTransaction(
    tx: BatchTransaction,
    signer: any
  ): Promise<ValidationResult> {
    try {
      // 余额检查
      const balance = await signer.getBalance();
      if (balance < tx.value) {
        return { isValid: false, error: '余额不足' };
      }

      // Gas 估算
      const gasEstimate = await signer.estimateGas(tx);
      if (!tx.gasLimit) {
        tx.gasLimit = gasEstimate * 12n / 10n; // 增加20%缓冲
      }

      return { isValid: true };
    } catch (error) {
      return { isValid: false, error: error.message };
    }
  }

  private static async shouldContinueOnError(
    error: any,
    currentIndex: number,
    totalCount: number
  ): Promise<boolean> {
    // 根据错误类型决定是否继续
    if (error.code === 'INSUFFICIENT_FUNDS') {
      return false; // 余额不足，停止执行
    }
    
    if (error.code === 'NONCE_EXPIRED') {
      return false; // Nonce 问题，停止执行
    }

    // 其他错误，继续执行（可配置）
    return true;
  }
}

// 使用示例
const useBatchTransaction = () => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState(0);
  const { address } = useAdvancedWallet();

  const executeBatch = async (transactions: BatchTransaction[]) => {
    if (!address) throw new Error('钱包未连接');

    setIsProcessing(true);
    setProgress(0);

    try {
      const signer = await getSigner();
      const result = await BatchTransactionService.executeBatchTransactions(
        transactions,
        signer
      );

      setProgress(100);
      return result;
    } finally {
      setIsProcessing(false);
    }
  };

  return {
    executeBatch,
    isProcessing,
    progress
  };
};
```

### 7.2 智能合约工厂模式

```typescript
// services/ContractFactory.ts
export class ContractFactory {
  private static contracts: Map<string, Contract> = new Map();

  static async getContract(
    address: `0x${string}`,
    abi: any[],
    signer?: any
  ): Promise<Contract> {
    const key = `${address}-${signer?.address || 'readonly'}`;
    
    if (this.contracts.has(key)) {
      return this.contracts.get(key)!;
    }

    const provider = signer || getDefaultProvider();
    const contract = new Contract(address, abi, provider);
    
    this.contracts.set(key, contract);
    return contract;
  }

  static async deployContract(
    bytecode: string,
    abi: any[],
    constructorArgs: any[] = [],
    signer: any
  ): Promise<DeploymentResult> {
    try {
      const factory = new ContractFactory(abi, bytecode, signer);
      
      // 估算部署成本
      const deployTx = factory.getDeployTransaction(...constructorArgs);
      const gasEstimate = await signer.estimateGas(deployTx);
      const gasPrice = await signer.getGasPrice();
      const deploymentCost = gasEstimate * gasPrice;

      console.log(`预计部署成本: ${formatEther(deploymentCost)} ETH`);

      // 部署合约
      const contract = await factory.deploy(...constructorArgs);
      await contract.deployed();

      return {
        success: true,
        contract,
        address: contract.address,
        deploymentCost,
        gasUsed: gasEstimate
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // 合约升级支持
  static async upgradeContract(
    proxyAddress: `0x${string}`,
    newImplementation: `0x${string}`,
    signer: any
  ): Promise<boolean> {
    try {
      const proxyContract = await this.getContract(
        proxyAddress,
        PROXY_ABI,
        signer
      );

      const tx = await proxyContract.upgradeTo(newImplementation);
      await tx.wait();

      return true;
    } catch (error) {
      console.error('合约升级失败:', error);
      return false;
    }
  }
}
```

---

## ✅ 总结与最佳实践

### 🎯 关键要点

1. **多钱包支持**：支持主流钱包，提供良好的用户选择
2. **安全第一**：实施多重安全检查和验证机制
3. **用户体验**：流畅的连接流程和清晰的状态反馈
4. **移动端适配**：针对移动设备优化交互体验
5. **错误处理**：完善的错误处理和恢复机制

### 🛡️ 安全清单

- [ ] 输入验证和清理
- [ ] 签名验证机制
- [ ] 交易前安全检查
- [ ] 恶意地址过滤
- [ ] 网络钓鱼保护

### 📱 用户体验清单

- [ ] 连接状态可视化
- [ ] 交易进度跟踪
- [ ] 错误信息友好
- [ ] 移动端适配
- [ ] 响应式设计

### 🚀 性能优化

- [ ] 组件懒加载
- [ ] 状态缓存管理
- [ ] 请求去重优化
- [ ] 批量操作支持
- [ ] 内存泄漏防护

通过遵循这些指南和最佳实践，你可以构建一个安全、高效、用户友好的 Web3 钱包集成系统! 🎉