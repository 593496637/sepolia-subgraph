# ğŸ”— Web3 é’±åŒ…é›†æˆå¢å¼ºæŒ‡å—

> ğŸ¯ **å…¨é¢æŒ‡å—**ï¼šä»åŸºç¡€è¿æ¥åˆ°é«˜çº§åŠŸèƒ½çš„å®Œæ•´é’±åŒ…é›†æˆæ–¹æ¡ˆ

## ğŸ“‹ æŒ‡å—æ¦‚è§ˆ

æœ¬æŒ‡å—å°†æ·±å…¥ä»‹ç» Web3 é’±åŒ…é›†æˆçš„æ–¹æ–¹é¢é¢ï¼ŒåŒ…æ‹¬ï¼š
- ğŸ”Œ å¤šé’±åŒ…æ”¯æŒå’Œè¿æ¥ç®¡ç†
- ğŸ’¼ è´¦æˆ·çŠ¶æ€å’Œä½™é¢ç›‘æ§
- ğŸ“ äº¤æ˜“ç­¾åå’Œå‘é€æµç¨‹
- ğŸ” å®‰å…¨æœ€ä½³å®è·µ
- ğŸš€ é«˜çº§åŠŸèƒ½å®ç°

---

## ğŸŒŸ ç¬¬ä¸€éƒ¨åˆ†ï¼šé’±åŒ…ç”Ÿæ€æ¦‚è§ˆ

### 1.1 ä¸»æµé’±åŒ…ç±»å‹

| é’±åŒ…ç±»å‹ | ä»£è¡¨äº§å“ | ç‰¹ç‚¹ | é›†æˆéš¾åº¦ | ç”¨æˆ·å æ¯” |
|----------|----------|------|----------|----------|
| **æµè§ˆå™¨æ‰©å±•** | MetaMask, Coinbase Wallet | åŠŸèƒ½ä¸°å¯Œã€å®‰å…¨æ€§é«˜ | ç®€å• | 70% |
| **ç§»åŠ¨ç«¯é’±åŒ…** | Trust Wallet, imToken | ç§»åŠ¨ä½“éªŒå¥½ | ä¸­ç­‰ | 20% |
| **ç¡¬ä»¶é’±åŒ…** | Ledger, Trezor | æœ€é«˜å®‰å…¨æ€§ | å¤æ‚ | 5% |
| **Webé’±åŒ…** | WalletConnect | è·¨å¹³å°å…¼å®¹ | ç®€å• | 5% |

### 1.2 æŠ€æœ¯é€‰æ‹©å¯¹æ¯”

```typescript
// ä¸åŒé’±åŒ…åº“å¯¹æ¯”
interface WalletLibrary {
  name: string;
  features: string[];
  pros: string[];
  cons: string[];
  recommend: boolean;
}

const walletLibraries: WalletLibrary[] = [
  {
    name: "Wagmi",
    features: ["React hooks", "TypeScriptæ”¯æŒ", "è‡ªåŠ¨ç±»å‹æ¨æ–­", "ç¼“å­˜ç®¡ç†"],
    pros: ["ç°ä»£åŒ–API", "å¼ºç±»å‹", "ç¤¾åŒºæ´»è·ƒ", "æ–‡æ¡£å®Œå–„"],
    cons: ["åªæ”¯æŒReact", "å­¦ä¹ æ›²çº¿"],
    recommend: true
  },
  {
    name: "Web3Modal",
    features: ["å¤šé’±åŒ…æ”¯æŒ", "UIç»„ä»¶", "ç§»åŠ¨ç«¯é€‚é…"],
    pros: ["æ˜“äºé›†æˆ", "UIç¾è§‚", "è·¨æ¡†æ¶"],
    cons: ["å®šåˆ¶æ€§æœ‰é™", "ä¾èµ–è¾ƒå¤š"],
    recommend: true
  },
  {
    name: "Ethers.js + æ‰‹åŠ¨é›†æˆ",
    features: ["å®Œå…¨æ§åˆ¶", "è½»é‡çº§"],
    pros: ["çµæ´»æ€§é«˜", "åŒ…ä½“ç§¯å°"],
    cons: ["å¼€å‘å¤æ‚", "éœ€è¦å¤„ç†å…¼å®¹æ€§"],
    recommend: false
  }
];
```

---

## ğŸ”§ ç¬¬äºŒéƒ¨åˆ†ï¼šWagmi æ·±åº¦é…ç½®

### 2.1 é«˜çº§é…ç½®é€‰é¡¹

```typescript
// config/wagmi-advanced.ts
import { createConfig, http, webSocket } from 'wagmi';
import { 
  mainnet, 
  sepolia, 
  polygon, 
  arbitrum 
} from 'wagmi/chains';
import {
  metaMask,
  walletConnect,
  coinbaseWallet,
  injected
} from 'wagmi/connectors';
import { createStorage } from 'wagmi';

// è‡ªå®šä¹‰é“¾é…ç½®
const customChains = [
  sepolia,
  // æ·»åŠ è‡ªå®šä¹‰ç½‘ç»œ
  {
    id: 31337,
    name: 'Localhost',
    network: 'localhost',
    nativeCurrency: {
      decimals: 18,
      name: 'Ethereum',
      symbol: 'ETH',
    },
    rpcUrls: {
      default: { http: ['http://127.0.0.1:8545'] },
      public: { http: ['http://127.0.0.1:8545'] },
    },
    blockExplorers: {
      default: { name: 'Local', url: 'http://localhost:8545' },
    },
  }
] as const;

// è¿æ¥å™¨é…ç½®
const projectId = process.env.NEXT_PUBLIC_WALLETCONNECT_PROJECT_ID!;

const connectors = [
  // MetaMask é…ç½®
  metaMask({
    dappMetadata: {
      name: 'Sepolia Web3 Explorer',
      url: 'https://your-domain.com',
      iconUrl: 'https://your-domain.com/icon.png'
    }
  }),

  // WalletConnect é…ç½®
  walletConnect({
    projectId,
    metadata: {
      name: 'Sepolia Web3 Explorer',
      description: 'Explore Ethereum transactions with dual data sources',
      url: 'https://your-domain.com',
      icons: ['https://your-domain.com/icon.png']
    },
    // æ”¯æŒçš„é“¾
    chains: customChains,
    // æ˜¾ç¤ºçš„é’±åŒ…
    showQrModal: true,
    qrModalOptions: {
      themeMode: 'light',
      themeVariables: {
        '--wcm-z-index': '1000'
      }
    }
  }),

  // Coinbase Wallet
  coinbaseWallet({
    appName: 'Sepolia Web3 Explorer',
    appLogoUrl: 'https://your-domain.com/icon.png',
    preference: 'smartWalletOnly' // ä¼˜å…ˆä½¿ç”¨æ™ºèƒ½é’±åŒ…
  }),

  // æ³¨å…¥å¼é’±åŒ…æ£€æµ‹
  injected({
    // è‡ªå®šä¹‰æ³¨å…¥å¼é’±åŒ…æ£€æµ‹
    shimDisconnect: true,
  })
];

// ä¼ è¾“é…ç½®
const transports = {
  [sepolia.id]: http('https://rpc.sepolia.org', {
    // è¯·æ±‚è¶…æ—¶
    timeout: 10000,
    // æ‰¹é‡è¯·æ±‚
    batch: true,
    // é‡è¯•é…ç½®
    retryCount: 3,
    retryDelay: 1000
  }),
  // WebSocket æ”¯æŒï¼ˆç”¨äºäº‹ä»¶ç›‘å¬ï¼‰
  [mainnet.id]: webSocket('wss://eth-mainnet.ws.alchemyapi.io/v2/your-key'),
  // æœ¬åœ°å¼€å‘
  [31337]: http('http://127.0.0.1:8545')
};

// å­˜å‚¨é…ç½®
const storage = createStorage({
  storage: typeof window !== 'undefined' ? localStorage : undefined,
  key: 'wagmi',
});

export const wagmiConfig = createConfig({
  chains: customChains,
  connectors,
  transports,
  storage,
  // SSR æ”¯æŒ
  ssr: false,
  // åŒæ­¥å¤–éƒ¨è¿æ¥å™¨çŠ¶æ€
  syncConnectedChain: true,
  // å¤šè¿æ¥å™¨æ”¯æŒ
  multiInjectedProviderDiscovery: true
});

// ç±»å‹å¢å¼º
declare module 'wagmi' {
  interface Register {
    config: typeof wagmiConfig;
  }
}
```

### 2.2 é«˜çº§ Hook å°è£…

```typescript
// hooks/useAdvancedWallet.ts
import { 
  useAccount, 
  useBalance, 
  useConnect, 
  useDisconnect,
  useChainId,
  useSwitchChain,
  useEnsName,
  useEnsAvatar
} from 'wagmi';
import { useCallback, useEffect, useState } from 'react';
import { formatEther } from 'viem';

interface WalletState {
  // è¿æ¥çŠ¶æ€
  isConnected: boolean;
  isConnecting: boolean;
  isDisconnecting: boolean;
  
  // è´¦æˆ·ä¿¡æ¯
  address?: `0x${string}`;
  ensName?: string;
  ensAvatar?: string;
  
  // ä½™é¢ä¿¡æ¯
  balance?: {
    value: bigint;
    formatted: string;
    symbol: string;
  };
  
  // ç½‘ç»œä¿¡æ¯
  chainId?: number;
  chainName?: string;
  
  // æ“ä½œæ–¹æ³•
  connect: (connectorId?: string) => Promise<void>;
  disconnect: () => Promise<void>;
  switchNetwork: (chainId: number) => Promise<void>;
  
  // é”™è¯¯ä¿¡æ¯
  error?: Error;
}

export const useAdvancedWallet = (): WalletState => {
  const [error, setError] = useState<Error>();
  
  const { address, isConnected, connector } = useAccount();
  const { connect: wagmiConnect, connectors, isPending: isConnecting } = useConnect();
  const { disconnect: wagmiDisconnect, isPending: isDisconnecting } = useDisconnect();
  const chainId = useChainId();
  const { switchChain } = useSwitchChain();
  
  // ENS ä¿¡æ¯
  const { data: ensName } = useEnsName({ 
    address,
    chainId: 1, // ä¸»ç½‘ ENS
  });
  
  const { data: ensAvatar } = useEnsAvatar({ 
    name: ensName!,
    chainId: 1,
  });

  // ä½™é¢ä¿¡æ¯
  const { data: balanceData, refetch: refetchBalance } = useBalance({
    address,
    query: {
      enabled: !!address,
      refetchInterval: 10000, // 10ç§’æ›´æ–°ä¸€æ¬¡
    }
  });

  // è¿æ¥é’±åŒ…
  const connect = useCallback(async (connectorId?: string) => {
    try {
      setError(undefined);
      
      let selectedConnector = connectors[0]; // é»˜è®¤ç¬¬ä¸€ä¸ª
      
      if (connectorId) {
        selectedConnector = connectors.find(c => c.id === connectorId) || connectors[0];
      }
      
      await wagmiConnect({ connector: selectedConnector });
    } catch (err) {
      setError(err as Error);
    }
  }, [wagmiConnect, connectors]);

  // æ–­å¼€è¿æ¥
  const disconnect = useCallback(async () => {
    try {
      setError(undefined);
      await wagmiDisconnect();
    } catch (err) {
      setError(err as Error);
    }
  }, [wagmiDisconnect]);

  // åˆ‡æ¢ç½‘ç»œ
  const switchNetwork = useCallback(async (targetChainId: number) => {
    try {
      setError(undefined);
      await switchChain({ chainId: targetChainId });
    } catch (err) {
      setError(err as Error);
    }
  }, [switchChain]);

  // ç›‘å¬è´¦æˆ·å˜åŒ–
  useEffect(() => {
    if (isConnected && address) {
      refetchBalance();
    }
  }, [isConnected, address, refetchBalance]);

  return {
    isConnected,
    isConnecting,
    isDisconnecting,
    address,
    ensName: ensName || undefined,
    ensAvatar: ensAvatar || undefined,
    balance: balanceData ? {
      value: balanceData.value,
      formatted: formatEther(balanceData.value),
      symbol: balanceData.symbol
    } : undefined,
    chainId,
    chainName: connector?.chains?.find(c => c.id === chainId)?.name,
    connect,
    disconnect,
    switchNetwork,
    error
  };
};
```

### 2.3 æ™ºèƒ½åˆçº¦äº¤äº’å°è£…

```typescript
// hooks/useSmartContract.ts
import { 
  useReadContract, 
  useWriteContract, 
  useWaitForTransactionReceipt,
  useWatchContractEvent
} from 'wagmi';
import { useCallback, useState } from 'react';
import { Abi, Address } from 'viem';

interface ContractConfig {
  address: Address;
  abi: Abi;
  chainId?: number;
}

interface WriteResult {
  hash?: `0x${string}`;
  isLoading: boolean;
  isSuccess: boolean;
  error?: Error;
  write: (args?: unknown[]) => Promise<void>;
}

export const useSmartContract = (config: ContractConfig) => {
  const [writeState, setWriteState] = useState<{
    hash?: `0x${string}`;
    isLoading: boolean;
    isSuccess: boolean;
    error?: Error;
  }>({
    isLoading: false,
    isSuccess: false
  });

  const { writeContract } = useWriteContract();

  // è¯»å–åˆçº¦
  const useContractRead = (functionName: string, args?: unknown[]) => {
    return useReadContract({
      ...config,
      functionName,
      args: args || []
    });
  };

  // å†™å…¥åˆçº¦
  const useContractWrite = (functionName: string): WriteResult => {
    const write = useCallback(async (args?: unknown[]) => {
      try {
        setWriteState({ isLoading: true, isSuccess: false });
        
        const hash = await writeContract({
          ...config,
          functionName,
          args: args || []
        });

        setWriteState({ 
          hash, 
          isLoading: false, 
          isSuccess: true 
        });
      } catch (error) {
        setWriteState({ 
          isLoading: false, 
          isSuccess: false,
          error: error as Error 
        });
      }
    }, [functionName]);

    return {
      ...writeState,
      write
    };
  };

  // ç›‘å¬åˆçº¦äº‹ä»¶
  const useWatchEvent = (
    eventName: string,
    onLogs: (logs: any[]) => void
  ) => {
    return useWatchContractEvent({
      ...config,
      eventName,
      onLogs,
      poll: true,
      pollingInterval: 1000
    });
  };

  // ç­‰å¾…äº¤æ˜“ç¡®è®¤
  const useWaitForTx = (hash?: `0x${string}`) => {
    return useWaitForTransactionReceipt({
      hash,
      query: {
        enabled: !!hash,
      }
    });
  };

  return {
    useContractRead,
    useContractWrite,
    useWatchEvent,
    useWaitForTx
  };
};
```

---

## ğŸ’¼ ç¬¬ä¸‰éƒ¨åˆ†ï¼šå¤šé’±åŒ…ç®¡ç†ç³»ç»Ÿ

### 3.1 é’±åŒ…ç®¡ç†å™¨å®ç°

```typescript
// services/WalletManager.ts
export class WalletManager {
  private static instance: WalletManager;
  private supportedWallets: Map<string, WalletInfo> = new Map();
  private currentWallet?: WalletInfo;
  private eventEmitter = new EventTarget();

  static getInstance() {
    if (!WalletManager.instance) {
      WalletManager.instance = new WalletManager();
    }
    return WalletManager.instance;
  }

  constructor() {
    this.initializeSupportedWallets();
    this.detectInstalledWallets();
  }

  private initializeSupportedWallets() {
    const wallets: WalletInfo[] = [
      {
        id: 'metamask',
        name: 'MetaMask',
        icon: '/icons/metamask.svg',
        downloadUrl: 'https://metamask.io/download/',
        isInstalled: false,
        isDetectable: true,
        connector: 'metaMask'
      },
      {
        id: 'coinbase',
        name: 'Coinbase Wallet',
        icon: '/icons/coinbase.svg',
        downloadUrl: 'https://www.coinbase.com/wallet',
        isInstalled: false,
        isDetectable: true,
        connector: 'coinbaseWallet'
      },
      {
        id: 'walletconnect',
        name: 'WalletConnect',
        icon: '/icons/walletconnect.svg',
        downloadUrl: 'https://walletconnect.com/',
        isInstalled: true, // æ€»æ˜¯å¯ç”¨
        isDetectable: false,
        connector: 'walletConnect'
      }
    ];

    wallets.forEach(wallet => {
      this.supportedWallets.set(wallet.id, wallet);
    });
  }

  private detectInstalledWallets() {
    // æ£€æµ‹ MetaMask
    if (typeof window !== 'undefined' && window.ethereum?.isMetaMask) {
      const metamask = this.supportedWallets.get('metamask');
      if (metamask) {
        metamask.isInstalled = true;
      }
    }

    // æ£€æµ‹ Coinbase Wallet
    if (typeof window !== 'undefined' && window.ethereum?.isCoinbaseWallet) {
      const coinbase = this.supportedWallets.get('coinbase');
      if (coinbase) {
        coinbase.isInstalled = true;
      }
    }

    // æ£€æµ‹å…¶ä»–æ³¨å…¥å¼é’±åŒ…
    this.detectOtherWallets();
  }

  private detectOtherWallets() {
    if (typeof window === 'undefined') return;

    const commonWallets = [
      { key: 'isTrust', name: 'Trust Wallet' },
      { key: 'isImToken', name: 'imToken' },
      { key: 'isBraveWallet', name: 'Brave Wallet' },
      { key: 'isRabby', name: 'Rabby' }
    ];

    commonWallets.forEach(({ key, name }) => {
      if (window.ethereum?.[key]) {
        this.supportedWallets.set(key.toLowerCase(), {
          id: key.toLowerCase(),
          name,
          icon: `/icons/${key.toLowerCase()}.svg`,
          downloadUrl: '',
          isInstalled: true,
          isDetectable: true,
          connector: 'injected'
        });
      }
    });
  }

  // è·å–æ‰€æœ‰æ”¯æŒçš„é’±åŒ…
  getSupportedWallets(): WalletInfo[] {
    return Array.from(this.supportedWallets.values());
  }

  // è·å–å·²å®‰è£…çš„é’±åŒ…
  getInstalledWallets(): WalletInfo[] {
    return Array.from(this.supportedWallets.values())
      .filter(wallet => wallet.isInstalled);
  }

  // æ¨èé’±åŒ…æ’åº
  getRecommendedWallets(): WalletInfo[] {
    const installed = this.getInstalledWallets();
    const notInstalled = Array.from(this.supportedWallets.values())
      .filter(wallet => !wallet.isInstalled);

    // ä¼˜å…ˆæ˜¾ç¤ºå·²å®‰è£…çš„é’±åŒ…
    return [...installed, ...notInstalled];
  }

  // è¿æ¥é’±åŒ…
  async connectWallet(walletId: string): Promise<boolean> {
    const wallet = this.supportedWallets.get(walletId);
    if (!wallet) {
      throw new Error(`ä¸æ”¯æŒçš„é’±åŒ…: ${walletId}`);
    }

    if (!wallet.isInstalled && wallet.isDetectable) {
      throw new Error(`é’±åŒ…æœªå®‰è£…: ${wallet.name}`);
    }

    try {
      // è¿™é‡Œé›†æˆ Wagmi çš„è¿æ¥é€»è¾‘
      // å‘é€è¿æ¥æˆåŠŸäº‹ä»¶
      this.currentWallet = wallet;
      this.emitEvent('wallet-connected', { wallet });
      return true;
    } catch (error) {
      this.emitEvent('wallet-error', { error, wallet });
      throw error;
    }
  }

  // æ–­å¼€è¿æ¥
  async disconnectWallet(): Promise<void> {
    if (this.currentWallet) {
      const previousWallet = this.currentWallet;
      this.currentWallet = undefined;
      this.emitEvent('wallet-disconnected', { wallet: previousWallet });
    }
  }

  // äº‹ä»¶ç›‘å¬
  addEventListener(eventType: string, callback: (event: CustomEvent) => void) {
    this.eventEmitter.addEventListener(eventType, callback as EventListener);
  }

  private emitEvent(eventType: string, data: any) {
    const event = new CustomEvent(eventType, { detail: data });
    this.eventEmitter.dispatchEvent(event);
  }
}

interface WalletInfo {
  id: string;
  name: string;
  icon: string;
  downloadUrl: string;
  isInstalled: boolean;
  isDetectable: boolean;
  connector: string;
}
```

### 3.2 é’±åŒ…é€‰æ‹©ç»„ä»¶

```tsx
// components/WalletModal.tsx
import React, { useState, useEffect } from 'react';
import { WalletManager } from '../services/WalletManager';
import { useAdvancedWallet } from '../hooks/useAdvancedWallet';

interface WalletModalProps {
  isOpen: boolean;
  onClose: () => void;
  onConnect: (walletId: string) => void;
}

export const WalletModal: React.FC<WalletModalProps> = ({
  isOpen,
  onClose,
  onConnect
}) => {
  const [wallets, setWallets] = useState<WalletInfo[]>([]);
  const [connecting, setConnecting] = useState<string | null>(null);
  const { connect, error } = useAdvancedWallet();

  useEffect(() => {
    const walletManager = WalletManager.getInstance();
    setWallets(walletManager.getRecommendedWallets());
  }, []);

  const handleWalletClick = async (wallet: WalletInfo) => {
    if (!wallet.isInstalled && wallet.isDetectable) {
      window.open(wallet.downloadUrl, '_blank');
      return;
    }

    try {
      setConnecting(wallet.id);
      await connect(wallet.connector);
      onConnect(wallet.id);
      onClose();
    } catch (error) {
      console.error('è¿æ¥å¤±è´¥:', error);
    } finally {
      setConnecting(null);
    }
  };

  if (!isOpen) return null;

  return (
    <div className="wallet-modal-overlay" onClick={onClose}>
      <div className="wallet-modal" onClick={e => e.stopPropagation()}>
        <div className="modal-header">
          <h2>è¿æ¥é’±åŒ…</h2>
          <button onClick={onClose} className="close-button">Ã—</button>
        </div>

        <div className="wallet-list">
          {wallets.map(wallet => (
            <button
              key={wallet.id}
              className={`wallet-item ${!wallet.isInstalled ? 'not-installed' : ''}`}
              onClick={() => handleWalletClick(wallet)}
              disabled={connecting === wallet.id}
            >
              <img src={wallet.icon} alt={wallet.name} className="wallet-icon" />
              <span className="wallet-name">{wallet.name}</span>
              
              {connecting === wallet.id && (
                <div className="spinner" />
              )}
              
              {!wallet.isInstalled && wallet.isDetectable && (
                <span className="install-badge">å®‰è£…</span>
              )}
              
              {wallet.isInstalled && (
                <span className="installed-badge">å·²å®‰è£…</span>
              )}
            </button>
          ))}
        </div>

        {error && (
          <div className="error-message">
            è¿æ¥å¤±è´¥: {error.message}
          </div>
        )}

        <div className="modal-footer">
          <p>
            è¿æ¥é’±åŒ…å³è¡¨ç¤ºæ‚¨åŒæ„æˆ‘ä»¬çš„
            <a href="/terms" target="_blank">æœåŠ¡æ¡æ¬¾</a>å’Œ
            <a href="/privacy" target="_blank">éšç§æ”¿ç­–</a>
          </p>
        </div>
      </div>
    </div>
  );
};
```

---

## ğŸ” ç¬¬å››éƒ¨åˆ†ï¼šå®‰å…¨æœ€ä½³å®è·µ

### 4.1 ç­¾åéªŒè¯ç³»ç»Ÿ

```typescript
// utils/signatureVerification.ts
import { verifyMessage, recoverMessageAddress } from 'viem';

export class SignatureVerificationService {
  
  // åˆ›å»ºç­¾åæ¶ˆæ¯
  static createSignMessage(
    action: string, 
    timestamp: number, 
    nonce: string,
    additionalData?: Record<string, any>
  ): string {
    const message = {
      action,
      timestamp,
      nonce,
      domain: window.location.origin,
      ...additionalData
    };

    return JSON.stringify(message, Object.keys(message).sort());
  }

  // è¯·æ±‚ç”¨æˆ·ç­¾å
  static async requestSignature(
    message: string,
    address: `0x${string}`,
    signMessage: (args: { message: string }) => Promise<`0x${string}`>
  ): Promise<`0x${string}`> {
    try {
      return await signMessage({ message });
    } catch (error) {
      console.error('ç­¾åå¤±è´¥:', error);
      throw new Error('ç”¨æˆ·æ‹’ç»ç­¾å');
    }
  }

  // éªŒè¯ç­¾å
  static async verifySignature(
    message: string,
    signature: `0x${string}`,
    expectedAddress: `0x${string}`
  ): Promise<boolean> {
    try {
      const recoveredAddress = await recoverMessageAddress({
        message,
        signature
      });

      return recoveredAddress.toLowerCase() === expectedAddress.toLowerCase();
    } catch (error) {
      console.error('ç­¾åéªŒè¯å¤±è´¥:', error);
      return false;
    }
  }

  // æ£€æŸ¥æ¶ˆæ¯æ—¶æ•ˆæ€§
  static isMessageValid(
    message: string,
    maxAgeMinutes: number = 10
  ): boolean {
    try {
      const parsed = JSON.parse(message);
      const messageTime = new Date(parsed.timestamp);
      const now = new Date();
      const diffMinutes = (now.getTime() - messageTime.getTime()) / (1000 * 60);

      return diffMinutes <= maxAgeMinutes;
    } catch {
      return false;
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
export const useMessageSigning = () => {
  const { signMessage } = useSignMessage();
  const { address } = useAdvancedWallet();

  const signAndVerify = async (action: string, data?: any) => {
    if (!address) throw new Error('é’±åŒ…æœªè¿æ¥');

    const timestamp = Date.now();
    const nonce = crypto.randomUUID();
    
    const message = SignatureVerificationService.createSignMessage(
      action, 
      timestamp, 
      nonce, 
      data
    );

    const signature = await SignatureVerificationService.requestSignature(
      message,
      address,
      signMessage
    );

    const isValid = await SignatureVerificationService.verifySignature(
      message,
      signature,
      address
    );

    if (!isValid) {
      throw new Error('ç­¾åéªŒè¯å¤±è´¥');
    }

    return { message, signature, timestamp, nonce };
  };

  return { signAndVerify };
};
```

### 4.2 äº¤æ˜“å®‰å…¨æ£€æŸ¥

```typescript
// services/TransactionSecurity.ts
export class TransactionSecurity {
  
  // äº¤æ˜“å‰å®‰å…¨æ£€æŸ¥
  static async performSecurityCheck(
    to: `0x${string}`,
    value: bigint,
    data?: `0x${string}`
  ): Promise<SecurityCheckResult> {
    const checks: SecurityCheck[] = [];

    // 1. åœ°å€éªŒè¯
    checks.push(await this.checkAddress(to));

    // 2. é‡‘é¢åˆç†æ€§æ£€æŸ¥
    checks.push(await this.checkAmount(value));

    // 3. åˆçº¦å®‰å…¨æ£€æŸ¥
    if (data && data !== '0x') {
      checks.push(await this.checkContractInteraction(to, data));
    }

    // 4. ç½‘ç»œé’“é±¼æ£€æŸ¥
    checks.push(await this.checkPhishingSite());

    const highRiskChecks = checks.filter(c => c.risk === 'high');
    const mediumRiskChecks = checks.filter(c => c.risk === 'medium');

    return {
      isRecommended: highRiskChecks.length === 0,
      riskLevel: this.calculateOverallRisk(checks),
      checks,
      warnings: [...highRiskChecks, ...mediumRiskChecks].map(c => c.message)
    };
  }

  private static async checkAddress(address: `0x${string}`): Promise<SecurityCheck> {
    // æ£€æŸ¥æ˜¯å¦ä¸ºå·²çŸ¥æ¶æ„åœ°å€
    const maliciousAddresses = await this.getMaliciousAddresses();
    
    if (maliciousAddresses.includes(address.toLowerCase())) {
      return {
        type: 'address',
        risk: 'high',
        message: 'è­¦å‘Šï¼šç›®æ ‡åœ°å€è¢«æ ‡è®°ä¸ºæ¶æ„åœ°å€ï¼',
        passed: false
      };
    }

    // æ£€æŸ¥æ˜¯å¦ä¸ºæ™ºèƒ½åˆçº¦
    const code = await this.getCode(address);
    if (code && code !== '0x') {
      return {
        type: 'address',
        risk: 'medium',
        message: 'ç›®æ ‡åœ°å€æ˜¯æ™ºèƒ½åˆçº¦ï¼Œè¯·ç¡®è®¤äº¤äº’æ„å›¾',
        passed: true
      };
    }

    return {
      type: 'address',
      risk: 'low',
      message: 'åœ°å€éªŒè¯é€šè¿‡',
      passed: true
    };
  }

  private static async checkAmount(value: bigint): Promise<SecurityCheck> {
    const ethValue = Number(value) / 1e18;
    
    if (ethValue > 10) {
      return {
        type: 'amount',
        risk: 'high',
        message: `é«˜é¢è½¬è´¦è­¦å‘Šï¼š${ethValue.toFixed(4)} ETH`,
        passed: false
      };
    }

    if (ethValue > 1) {
      return {
        type: 'amount',
        risk: 'medium',
        message: `ä¸­ç­‰é‡‘é¢è½¬è´¦ï¼š${ethValue.toFixed(4)} ETH`,
        passed: true
      };
    }

    return {
      type: 'amount',
      risk: 'low',
      message: 'è½¬è´¦é‡‘é¢æ­£å¸¸',
      passed: true
    };
  }

  private static async checkContractInteraction(
    address: `0x${string}`,
    data: `0x${string}`
  ): Promise<SecurityCheck> {
    try {
      // è§£æå‡½æ•°é€‰æ‹©å™¨
      const functionSelector = data.slice(0, 10);
      
      // æ£€æŸ¥å·²çŸ¥å±é™©å‡½æ•°
      const dangerousFunctions = [
        '0xa9059cbb', // transfer
        '0x23b872dd', // transferFrom
        '0x095ea7b3', // approve
      ];

      if (dangerousFunctions.includes(functionSelector)) {
        return {
          type: 'contract',
          risk: 'medium',
          message: 'æ­£åœ¨è°ƒç”¨ä»£å¸è½¬è´¦ç›¸å…³å‡½æ•°ï¼Œè¯·ç¡®è®¤æ“ä½œ',
          passed: true
        };
      }

      return {
        type: 'contract',
        risk: 'low',
        message: 'åˆçº¦äº¤äº’å®‰å…¨æ£€æŸ¥é€šè¿‡',
        passed: true
      };
    } catch {
      return {
        type: 'contract',
        risk: 'medium',
        message: 'æ— æ³•è§£æåˆçº¦è°ƒç”¨æ•°æ®',
        passed: true
      };
    }
  }

  private static async checkPhishingSite(): Promise<SecurityCheck> {
    const currentDomain = window.location.hostname;
    
    // æ£€æŸ¥æ˜¯å¦ä¸ºå·²çŸ¥é’“é±¼ç½‘ç«™
    const phishingDomains = await this.getPhishingDomains();
    
    if (phishingDomains.includes(currentDomain)) {
      return {
        type: 'phishing',
        risk: 'high',
        message: 'è­¦å‘Šï¼šå½“å‰ç½‘ç«™å¯èƒ½æ˜¯é’“é±¼ç½‘ç«™ï¼',
        passed: false
      };
    }

    return {
      type: 'phishing',
      risk: 'low',
      message: 'ç½‘ç«™å®‰å…¨æ£€æŸ¥é€šè¿‡',
      passed: true
    };
  }

  private static calculateOverallRisk(checks: SecurityCheck[]): 'low' | 'medium' | 'high' {
    const hasHigh = checks.some(c => c.risk === 'high');
    const hasMedium = checks.some(c => c.risk === 'medium');
    
    if (hasHigh) return 'high';
    if (hasMedium) return 'medium';
    return 'low';
  }

  // æ¨¡æ‹Ÿæ•°æ®æºï¼Œå®é™…åº”ç”¨ä¸­åº”è¯¥ä»å¯ä¿¡çš„APIè·å–
  private static async getMaliciousAddresses(): Promise<string[]> {
    // ä»å®‰å…¨æœåŠ¡è·å–æ¶æ„åœ°å€åˆ—è¡¨
    return [];
  }

  private static async getPhishingDomains(): Promise<string[]> {
    // ä»å®‰å…¨æœåŠ¡è·å–é’“é±¼åŸŸååˆ—è¡¨
    return [];
  }

  private static async getCode(address: `0x${string}`): Promise<`0x${string}` | null> {
    // è·å–åœ°å€çš„å­—èŠ‚ç 
    return null;
  }
}

interface SecurityCheck {
  type: 'address' | 'amount' | 'contract' | 'phishing';
  risk: 'low' | 'medium' | 'high';
  message: string;
  passed: boolean;
}

interface SecurityCheckResult {
  isRecommended: boolean;
  riskLevel: 'low' | 'medium' | 'high';
  checks: SecurityCheck[];
  warnings: string[];
}
```

---

## ğŸ“Š ç¬¬äº”éƒ¨åˆ†ï¼šç”¨æˆ·ä½“éªŒä¼˜åŒ–

### 5.1 è¿æ¥çŠ¶æ€ç®¡ç†

```tsx
// components/WalletStatus.tsx
import React from 'react';
import { useAdvancedWallet } from '../hooks/useAdvancedWallet';

export const WalletStatus: React.FC = () => {
  const { 
    isConnected, 
    isConnecting, 
    address, 
    ensName,
    ensAvatar,
    balance, 
    chainName,
    disconnect,
    error 
  } = useAdvancedWallet();

  const formatAddress = (addr: string) => {
    return `${addr.slice(0, 6)}...${addr.slice(-4)}`;
  };

  if (isConnecting) {
    return (
      <div className="wallet-status connecting">
        <div className="spinner" />
        <span>è¿æ¥ä¸­...</span>
      </div>
    );
  }

  if (!isConnected) {
    return (
      <div className="wallet-status disconnected">
        <span>æœªè¿æ¥é’±åŒ…</span>
      </div>
    );
  }

  if (error) {
    return (
      <div className="wallet-status error">
        <span>è¿æ¥é”™è¯¯: {error.message}</span>
        <button onClick={() => window.location.reload()}>
          é‡è¯•
        </button>
      </div>
    );
  }

  return (
    <div className="wallet-status connected">
      <div className="wallet-info">
        {ensAvatar && (
          <img src={ensAvatar} alt="Avatar" className="wallet-avatar" />
        )}
        <div className="wallet-details">
          <div className="wallet-address">
            {ensName || formatAddress(address!)}
          </div>
          <div className="wallet-balance">
            {balance?.formatted} {balance?.symbol}
          </div>
          <div className="wallet-network">
            {chainName}
          </div>
        </div>
      </div>
      <button onClick={disconnect} className="disconnect-button">
        æ–­å¼€
      </button>
    </div>
  );
};
```

### 5.2 äº¤æ˜“çŠ¶æ€è·Ÿè¸ª

```tsx
// components/TransactionTracker.tsx
import React, { useEffect, useState } from 'react';
import { useWaitForTransactionReceipt } from 'wagmi';

interface TransactionTrackerProps {
  hash?: `0x${string}`;
  onSuccess?: (receipt: any) => void;
  onError?: (error: Error) => void;
}

export const TransactionTracker: React.FC<TransactionTrackerProps> = ({
  hash,
  onSuccess,
  onError
}) => {
  const [elapsedTime, setElapsedTime] = useState(0);
  const [startTime] = useState(Date.now());

  const { 
    data: receipt, 
    isLoading, 
    isSuccess, 
    error 
  } = useWaitForTransactionReceipt({
    hash,
    query: {
      enabled: !!hash,
    }
  });

  // æ›´æ–°ç»è¿‡æ—¶é—´
  useEffect(() => {
    if (!isLoading) return;

    const timer = setInterval(() => {
      setElapsedTime(Math.floor((Date.now() - startTime) / 1000));
    }, 1000);

    return () => clearInterval(timer);
  }, [isLoading, startTime]);

  // å¤„ç†æˆåŠŸå’Œé”™è¯¯
  useEffect(() => {
    if (isSuccess && receipt && onSuccess) {
      onSuccess(receipt);
    }
  }, [isSuccess, receipt, onSuccess]);

  useEffect(() => {
    if (error && onError) {
      onError(error);
    }
  }, [error, onError]);

  if (!hash) return null;

  const getStatusColor = () => {
    if (error) return '#f44336';
    if (isSuccess) return '#4caf50';
    return '#ff9800';
  };

  const getStatusText = () => {
    if (error) return 'äº¤æ˜“å¤±è´¥';
    if (isSuccess) return 'äº¤æ˜“æˆåŠŸ';
    return 'ç¡®è®¤ä¸­...';
  };

  return (
    <div className="transaction-tracker">
      <div className="tracker-header">
        <div 
          className="status-indicator" 
          style={{ backgroundColor: getStatusColor() }}
        />
        <span className="status-text">{getStatusText()}</span>
      </div>

      <div className="tracker-details">
        <div className="detail-row">
          <span>äº¤æ˜“å“ˆå¸Œ:</span>
          <a 
            href={`https://sepolia.etherscan.io/tx/${hash}`}
            target="_blank"
            rel="noopener noreferrer"
            className="tx-link"
          >
            {`${hash.slice(0, 10)}...${hash.slice(-8)}`}
          </a>
        </div>

        {isLoading && (
          <div className="detail-row">
            <span>ç­‰å¾…æ—¶é—´:</span>
            <span>{elapsedTime}ç§’</span>
          </div>
        )}

        {receipt && (
          <>
            <div className="detail-row">
              <span>åŒºå—å·:</span>
              <span>{receipt.blockNumber.toString()}</span>
            </div>
            <div className="detail-row">
              <span>Gas ä½¿ç”¨:</span>
              <span>{receipt.gasUsed.toString()}</span>
            </div>
            <div className="detail-row">
              <span>äº¤æ˜“è´¹ç”¨:</span>
              <span>
                {((receipt.gasUsed * receipt.effectiveGasPrice) / 1e18).toFixed(6)} ETH
              </span>
            </div>
          </>
        )}

        {error && (
          <div className="detail-row error">
            <span>é”™è¯¯ä¿¡æ¯:</span>
            <span>{error.message}</span>
          </div>
        )}
      </div>

      {isLoading && (
        <div className="progress-bar">
          <div className="progress-fill" />
        </div>
      )}
    </div>
  );
};
```

### 5.3 ç½‘ç»œåˆ‡æ¢æç¤º

```tsx
// components/NetworkSwitcher.tsx
import React, { useState } from 'react';
import { useAdvancedWallet } from '../hooks/useAdvancedWallet';
import { sepolia, mainnet } from 'wagmi/chains';

const SUPPORTED_NETWORKS = [
  { ...sepolia, icon: '/icons/ethereum.svg' },
  { ...mainnet, icon: '/icons/ethereum.svg' }
];

export const NetworkSwitcher: React.FC = () => {
  const { chainId, switchNetwork, error } = useAdvancedWallet();
  const [isSwitching, setIsSwitching] = useState(false);

  const currentNetwork = SUPPORTED_NETWORKS.find(n => n.id === chainId);
  const isUnsupportedNetwork = !currentNetwork;

  const handleNetworkSwitch = async (targetChainId: number) => {
    try {
      setIsSwitching(true);
      await switchNetwork(targetChainId);
    } catch (err) {
      console.error('ç½‘ç»œåˆ‡æ¢å¤±è´¥:', err);
    } finally {
      setIsSwitching(false);
    }
  };

  if (isUnsupportedNetwork) {
    return (
      <div className="network-switcher unsupported">
        <div className="warning-icon">âš ï¸</div>
        <div className="warning-text">
          <h3>ä¸æ”¯æŒçš„ç½‘ç»œ</h3>
          <p>è¯·åˆ‡æ¢åˆ°æ”¯æŒçš„ç½‘ç»œä»¥ç»§ç»­ä½¿ç”¨</p>
        </div>
        <div className="network-options">
          {SUPPORTED_NETWORKS.map(network => (
            <button
              key={network.id}
              onClick={() => handleNetworkSwitch(network.id)}
              disabled={isSwitching}
              className="network-button"
            >
              <img src={network.icon} alt={network.name} />
              <span>{network.name}</span>
            </button>
          ))}
        </div>
      </div>
    );
  }

  return (
    <div className="network-switcher supported">
      <div className="current-network">
        <img src={currentNetwork.icon} alt={currentNetwork.name} />
        <span>{currentNetwork.name}</span>
        <div className="network-status connected">
          â— å·²è¿æ¥
        </div>
      </div>

      <div className="other-networks">
        {SUPPORTED_NETWORKS
          .filter(n => n.id !== chainId)
          .map(network => (
            <button
              key={network.id}
              onClick={() => handleNetworkSwitch(network.id)}
              disabled={isSwitching}
              className="network-option"
            >
              <img src={network.icon} alt={network.name} />
              <span>{network.name}</span>
            </button>
          ))
        }
      </div>

      {error && (
        <div className="error-message">
          ç½‘ç»œåˆ‡æ¢å¤±è´¥: {error.message}
        </div>
      )}
    </div>
  );
};
```

---

## ğŸ“± ç¬¬å…­éƒ¨åˆ†ï¼šç§»åŠ¨ç«¯é€‚é…

### 6.1 å“åº”å¼é’±åŒ…è¿æ¥

```tsx
// hooks/useMobileWallet.ts
import { useEffect, useState } from 'react';
import { useAdvancedWallet } from './useAdvancedWallet';

export const useMobileWallet = () => {
  const [isMobile, setIsMobile] = useState(false);
  const [isInAppBrowser, setIsInAppBrowser] = useState(false);
  const wallet = useAdvancedWallet();

  useEffect(() => {
    const checkMobile = () => {
      const isMobileDevice = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
      setIsMobile(isMobileDevice);

      // æ£€æŸ¥æ˜¯å¦åœ¨åº”ç”¨å†…æµè§ˆå™¨ä¸­
      const isInApp = /MetaMaskMobile|Trust|imToken|Coinbase/i.test(navigator.userAgent);
      setIsInAppBrowser(isInApp);
    };

    checkMobile();
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  const connectMobileWallet = async () => {
    if (isInAppBrowser) {
      // ç›´æ¥è¿æ¥æ³¨å…¥çš„é’±åŒ…
      return wallet.connect('injected');
    } else {
      // ä½¿ç”¨ WalletConnect
      return wallet.connect('walletConnect');
    }
  };

  const openInWallet = (url: string, walletName: string) => {
    const walletUrls = {
      metamask: `https://metamask.app.link/dapp/${url}`,
      trust: `https://link.trustwallet.com/open_url?coin_id=60&url=${url}`,
      coinbase: `https://go.cb-w.com/dapp?cb_url=${url}`,
      imtoken: `imtokenv2://navigate/DApp?url=${url}`
    };

    const walletUrl = walletUrls[walletName as keyof typeof walletUrls];
    if (walletUrl) {
      window.location.href = walletUrl;
    }
  };

  return {
    isMobile,
    isInAppBrowser,
    connectMobileWallet,
    openInWallet,
    ...wallet
  };
};
```

### 6.2 ç§»åŠ¨ç«¯å‹å¥½çš„é’±åŒ…é€‰æ‹©å™¨

```tsx
// components/MobileWalletSelector.tsx
import React, { useState } from 'react';
import { useMobileWallet } from '../hooks/useMobileWallet';

export const MobileWalletSelector: React.FC = () => {
  const { 
    isMobile, 
    isInAppBrowser, 
    connectMobileWallet, 
    openInWallet,
    isConnected,
    isConnecting 
  } = useMobileWallet();

  const [selectedWallet, setSelectedWallet] = useState<string>('');

  if (!isMobile) {
    return null; // ä½¿ç”¨æ¡Œé¢ç‰ˆé’±åŒ…é€‰æ‹©å™¨
  }

  const mobileWallets = [
    { id: 'metamask', name: 'MetaMask', color: '#f6851b' },
    { id: 'trust', name: 'Trust Wallet', color: '#3375bb' },
    { id: 'coinbase', name: 'Coinbase Wallet', color: '#0052ff' },
    { id: 'imtoken', name: 'imToken', color: '#11c4d1' }
  ];

  const handleWalletSelect = async (walletId: string) => {
    setSelectedWallet(walletId);

    if (isInAppBrowser) {
      // åœ¨é’±åŒ…åº”ç”¨å†…ï¼Œç›´æ¥è¿æ¥
      await connectMobileWallet();
    } else {
      // åœ¨æ™®é€šæµè§ˆå™¨ä¸­ï¼Œå°è¯•æ‰“å¼€é’±åŒ…åº”ç”¨
      const currentUrl = window.location.href;
      openInWallet(currentUrl, walletId);
    }
  };

  return (
    <div className="mobile-wallet-selector">
      <h2>é€‰æ‹©é’±åŒ…</h2>
      
      {isInAppBrowser ? (
        <div className="in-app-browser">
          <p>æ£€æµ‹åˆ°é’±åŒ…åº”ç”¨ç¯å¢ƒ</p>
          <button 
            onClick={connectMobileWallet}
            disabled={isConnecting}
            className="connect-button"
          >
            {isConnecting ? 'è¿æ¥ä¸­...' : 'è¿æ¥é’±åŒ…'}
          </button>
        </div>
      ) : (
        <div className="wallet-grid">
          {mobileWallets.map(wallet => (
            <button
              key={wallet.id}
              onClick={() => handleWalletSelect(wallet.id)}
              disabled={isConnecting && selectedWallet === wallet.id}
              className="wallet-card"
              style={{ borderColor: wallet.color }}
            >
              <div 
                className="wallet-icon"
                style={{ backgroundColor: wallet.color }}
              >
                {wallet.name.charAt(0)}
              </div>
              <span className="wallet-name">{wallet.name}</span>
              {isConnecting && selectedWallet === wallet.id && (
                <div className="connecting">è¿æ¥ä¸­...</div>
              )}
            </button>
          ))}
        </div>
      )}

      <div className="mobile-tips">
        <h3>ç§»åŠ¨ç«¯ä½¿ç”¨æç¤º:</h3>
        <ul>
          <li>ç¡®ä¿å·²å®‰è£…å¯¹åº”çš„é’±åŒ…åº”ç”¨</li>
          <li>é¦–æ¬¡è¿æ¥å¯èƒ½éœ€è¦åœ¨é’±åŒ…ä¸­ç¡®è®¤</li>
          <li>è¿æ¥åè¿”å›æµè§ˆå™¨ç»§ç»­æ“ä½œ</li>
        </ul>
      </div>
    </div>
  );
};
```

---

## ğŸ”§ ç¬¬ä¸ƒéƒ¨åˆ†ï¼šé«˜çº§åŠŸèƒ½å®ç°

### 7.1 æ‰¹é‡äº¤æ˜“å¤„ç†

```typescript
// services/BatchTransactionService.ts
interface BatchTransaction {
  to: `0x${string}`;
  value: bigint;
  data?: `0x${string}`;
  gasLimit?: bigint;
}

export class BatchTransactionService {
  
  static async executeBatchTransactions(
    transactions: BatchTransaction[],
    signer: any
  ): Promise<BatchTransactionResult> {
    const results: TransactionResult[] = [];
    let totalGasUsed = 0n;
    let totalValue = 0n;

    // é¢„æ£€æŸ¥æ‰€æœ‰äº¤æ˜“
    for (const tx of transactions) {
      const check = await this.validateTransaction(tx, signer);
      if (!check.isValid) {
        return {
          success: false,
          error: `äº¤æ˜“éªŒè¯å¤±è´¥: ${check.error}`,
          results: []
        };
      }
    }

    // æ‰§è¡Œäº¤æ˜“
    for (let i = 0; i < transactions.length; i++) {
      const tx = transactions[i];
      
      try {
        console.log(`æ‰§è¡Œäº¤æ˜“ ${i + 1}/${transactions.length}`);
        
        const txResponse = await signer.sendTransaction({
          to: tx.to,
          value: tx.value,
          data: tx.data,
          gasLimit: tx.gasLimit
        });

        const receipt = await txResponse.wait();
        
        results.push({
          index: i,
          hash: txResponse.hash,
          success: true,
          gasUsed: receipt.gasUsed,
          receipt
        });

        totalGasUsed += receipt.gasUsed;
        totalValue += tx.value;

      } catch (error) {
        results.push({
          index: i,
          hash: null,
          success: false,
          error: error.message,
          gasUsed: 0n
        });

        // æ˜¯å¦ç»§ç»­æ‰§è¡Œåç»­äº¤æ˜“ï¼ˆå¯é…ç½®ï¼‰
        const shouldContinue = await this.shouldContinueOnError(error, i, transactions.length);
        if (!shouldContinue) break;
      }
    }

    const successCount = results.filter(r => r.success).length;
    
    return {
      success: successCount === transactions.length,
      results,
      summary: {
        total: transactions.length,
        successful: successCount,
        failed: transactions.length - successCount,
        totalGasUsed,
        totalValue
      }
    };
  }

  private static async validateTransaction(
    tx: BatchTransaction,
    signer: any
  ): Promise<ValidationResult> {
    try {
      // ä½™é¢æ£€æŸ¥
      const balance = await signer.getBalance();
      if (balance < tx.value) {
        return { isValid: false, error: 'ä½™é¢ä¸è¶³' };
      }

      // Gas ä¼°ç®—
      const gasEstimate = await signer.estimateGas(tx);
      if (!tx.gasLimit) {
        tx.gasLimit = gasEstimate * 12n / 10n; // å¢åŠ 20%ç¼“å†²
      }

      return { isValid: true };
    } catch (error) {
      return { isValid: false, error: error.message };
    }
  }

  private static async shouldContinueOnError(
    error: any,
    currentIndex: number,
    totalCount: number
  ): Promise<boolean> {
    // æ ¹æ®é”™è¯¯ç±»å‹å†³å®šæ˜¯å¦ç»§ç»­
    if (error.code === 'INSUFFICIENT_FUNDS') {
      return false; // ä½™é¢ä¸è¶³ï¼Œåœæ­¢æ‰§è¡Œ
    }
    
    if (error.code === 'NONCE_EXPIRED') {
      return false; // Nonce é—®é¢˜ï¼Œåœæ­¢æ‰§è¡Œ
    }

    // å…¶ä»–é”™è¯¯ï¼Œç»§ç»­æ‰§è¡Œï¼ˆå¯é…ç½®ï¼‰
    return true;
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const useBatchTransaction = () => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState(0);
  const { address } = useAdvancedWallet();

  const executeBatch = async (transactions: BatchTransaction[]) => {
    if (!address) throw new Error('é’±åŒ…æœªè¿æ¥');

    setIsProcessing(true);
    setProgress(0);

    try {
      const signer = await getSigner();
      const result = await BatchTransactionService.executeBatchTransactions(
        transactions,
        signer
      );

      setProgress(100);
      return result;
    } finally {
      setIsProcessing(false);
    }
  };

  return {
    executeBatch,
    isProcessing,
    progress
  };
};
```

### 7.2 æ™ºèƒ½åˆçº¦å·¥å‚æ¨¡å¼

```typescript
// services/ContractFactory.ts
export class ContractFactory {
  private static contracts: Map<string, Contract> = new Map();

  static async getContract(
    address: `0x${string}`,
    abi: any[],
    signer?: any
  ): Promise<Contract> {
    const key = `${address}-${signer?.address || 'readonly'}`;
    
    if (this.contracts.has(key)) {
      return this.contracts.get(key)!;
    }

    const provider = signer || getDefaultProvider();
    const contract = new Contract(address, abi, provider);
    
    this.contracts.set(key, contract);
    return contract;
  }

  static async deployContract(
    bytecode: string,
    abi: any[],
    constructorArgs: any[] = [],
    signer: any
  ): Promise<DeploymentResult> {
    try {
      const factory = new ContractFactory(abi, bytecode, signer);
      
      // ä¼°ç®—éƒ¨ç½²æˆæœ¬
      const deployTx = factory.getDeployTransaction(...constructorArgs);
      const gasEstimate = await signer.estimateGas(deployTx);
      const gasPrice = await signer.getGasPrice();
      const deploymentCost = gasEstimate * gasPrice;

      console.log(`é¢„è®¡éƒ¨ç½²æˆæœ¬: ${formatEther(deploymentCost)} ETH`);

      // éƒ¨ç½²åˆçº¦
      const contract = await factory.deploy(...constructorArgs);
      await contract.deployed();

      return {
        success: true,
        contract,
        address: contract.address,
        deploymentCost,
        gasUsed: gasEstimate
      };
    } catch (error) {
      return {
        success: false,
        error: error.message
      };
    }
  }

  // åˆçº¦å‡çº§æ”¯æŒ
  static async upgradeContract(
    proxyAddress: `0x${string}`,
    newImplementation: `0x${string}`,
    signer: any
  ): Promise<boolean> {
    try {
      const proxyContract = await this.getContract(
        proxyAddress,
        PROXY_ABI,
        signer
      );

      const tx = await proxyContract.upgradeTo(newImplementation);
      await tx.wait();

      return true;
    } catch (error) {
      console.error('åˆçº¦å‡çº§å¤±è´¥:', error);
      return false;
    }
  }
}
```

---

## âœ… æ€»ç»“ä¸æœ€ä½³å®è·µ

### ğŸ¯ å…³é”®è¦ç‚¹

1. **å¤šé’±åŒ…æ”¯æŒ**ï¼šæ”¯æŒä¸»æµé’±åŒ…ï¼Œæä¾›è‰¯å¥½çš„ç”¨æˆ·é€‰æ‹©
2. **å®‰å…¨ç¬¬ä¸€**ï¼šå®æ–½å¤šé‡å®‰å…¨æ£€æŸ¥å’ŒéªŒè¯æœºåˆ¶
3. **ç”¨æˆ·ä½“éªŒ**ï¼šæµç•…çš„è¿æ¥æµç¨‹å’Œæ¸…æ™°çš„çŠ¶æ€åé¦ˆ
4. **ç§»åŠ¨ç«¯é€‚é…**ï¼šé’ˆå¯¹ç§»åŠ¨è®¾å¤‡ä¼˜åŒ–äº¤äº’ä½“éªŒ
5. **é”™è¯¯å¤„ç†**ï¼šå®Œå–„çš„é”™è¯¯å¤„ç†å’Œæ¢å¤æœºåˆ¶

### ğŸ›¡ï¸ å®‰å…¨æ¸…å•

- [ ] è¾“å…¥éªŒè¯å’Œæ¸…ç†
- [ ] ç­¾åéªŒè¯æœºåˆ¶
- [ ] äº¤æ˜“å‰å®‰å…¨æ£€æŸ¥
- [ ] æ¶æ„åœ°å€è¿‡æ»¤
- [ ] ç½‘ç»œé’“é±¼ä¿æŠ¤

### ğŸ“± ç”¨æˆ·ä½“éªŒæ¸…å•

- [ ] è¿æ¥çŠ¶æ€å¯è§†åŒ–
- [ ] äº¤æ˜“è¿›åº¦è·Ÿè¸ª
- [ ] é”™è¯¯ä¿¡æ¯å‹å¥½
- [ ] ç§»åŠ¨ç«¯é€‚é…
- [ ] å“åº”å¼è®¾è®¡

### ğŸš€ æ€§èƒ½ä¼˜åŒ–

- [ ] ç»„ä»¶æ‡’åŠ è½½
- [ ] çŠ¶æ€ç¼“å­˜ç®¡ç†
- [ ] è¯·æ±‚å»é‡ä¼˜åŒ–
- [ ] æ‰¹é‡æ“ä½œæ”¯æŒ
- [ ] å†…å­˜æ³„æ¼é˜²æŠ¤

é€šè¿‡éµå¾ªè¿™äº›æŒ‡å—å’Œæœ€ä½³å®è·µï¼Œä½ å¯ä»¥æ„å»ºä¸€ä¸ªå®‰å…¨ã€é«˜æ•ˆã€ç”¨æˆ·å‹å¥½çš„ Web3 é’±åŒ…é›†æˆç³»ç»Ÿ! ğŸ‰